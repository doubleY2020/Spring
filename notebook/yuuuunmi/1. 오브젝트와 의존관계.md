스프링은
- 자바가 객체지향 프로그래밍이 가능한 언어라는 점을 가장 중요하게 가치를 둔다.
- 그래서 오브젝트를 어떻게 효과적으로 설계, 구현, 사용, 개선할 것인가에 대한 기준을 마련해준다.
- 동시에 객체지향 기술과 설계, 구현에 관한 실용적인 전략과 검증된 베스트 프랙티스를 쉽게 적용할 수 있도록 프레임 워크 형태로 제공한다.




# 1.1 초난감 DAO

> DAO : Data Access Object
> DB를 사용해 데이터를 조회하거나 조작하는 기능을 전담

## 1.1.1~2 User, UserDao

> 자바 빈 : 다음의 두 관례를 따라 만들어진 오브젝트를 가르킨다
> 디폴트 생성자를 가진다. (리플렉션을 이용하여 오브젝트를 생성하기 때문)
> 프로퍼티를 가지고, 접근자(getter)와 수정자(setter)가 존재한다.  


`UserDao` 클래스가 동작하는지 어떻게 알 수 있을까?
 - 웹 애플리케이션을 만들어 서버에 배치하고, 웹 브라우저를 통해 DAO 기능을 테스트한다.
    - 배보다 배꼽이 크다.

## 1.1.3 main()을 이용한 DAO 테스트 코드
코드의 기능 검증을 위한 방법으로 자신을 엔트리 포인트로 설정해 직접 실행이 가능하게 해주는 스태틱 메소드(`main()`)를 사용한다.



현재의 `UserDao`는 왜 코드에 문제가 많다고 하는 것일까?
잘 동작하는 코드를 굳이 수정하고 개선해야 하는 이유는 뭘까?
개선했을 때의 단기적/장기적 장점은 무엇일까?
객체지향 설계의 원칙과 무슨 상관이 있을까?
개선하는 경우와 그대로 사용하는 경우, 스프링을 사용하는 개발에서는 무슨 차이가 있을까?


# 1.2 DAO의 분리

## 1.2.1 관심사의 분리
소프트웨어 개발에서 요구사항은 끊임없이 바뀌고 발전한다. 그에 따라 오브젝트에 대한 설계와 이를 구현한 코드 역시 변한다.
그러므로 개발자가 객체를 설계할 때 가장 염두에 둬야 할 것은 미래의 **변화** 를 어떻게 대비할 것인가이다,

객체지향 설계와 프로그래밍은 변화에 효과적으로 대처할 수 있다는 기술적인 특징이 있다.  
실세계에 최대한 가깝게 모델링해낼 수 있기 때문이기도 하고
가상의 추상세계 자체를 효과적으로 구상할 수 있으며,
이를 자유롭고 편리하게 변경, 발전, 확장시킬 수 있다는 데 더 큰 의미가 있다.

그렇다면 변화에 어떻게 대비할 것인가 ?
-> **변화의 폭을 최소한 줄여주는 것** 이 가장 좋은 대책이다.

**어떻게 변경이 일어날 때 필요한 작업을 최소화하고, 그 변경이 다른 곳에 문제를 일으키지 않게 할 수 있을까?**  
: 분리와 확장을 고려한 설계가 필요하다.



> **변화**(미래) 대응법 : **분리** 와 **확장** 을 고려한 설계

변화가 한 가지 관심에 집중돼서 일어난다면 우리는 한가지 관심이 한 군데에 집중되게 한다.  
즉 관심이 같은 것끼리는 모으고, 관심이 다른 것은 따로 떨어져 있게 하는 것이다.

관심사가 같은 것끼리 모으고 다른 것은 분리해줌으로써 같은 관심에 효과적으로 집중할 수 있게 만들어주는 것이다.

## 1.2.2 커넥션 만들기의 추출

`UserDao`에서는 세 가지 관심사항을 발견할 수 있다.

  1. DB와 연결을 위한 커넥션을 어떻게 가져올까?
  2. DB에 보낼 SPL 문장을 담은 Statement를 어떻게 만들고 실행할까?
  3. 사용 완료한 공유 자원(Statement, Connection 오브젝트)를 어떻게 시스템에 반환할까?

가장 문제가 되는 부분은 1번이 `add()` 메소드와 `get()` 메소드에 각각 중복으로 구현되어 있다. 이는 DAO 내 메소드가 많아지면 많아질 수록 같은 관심에 대해서 수정 범위가 넓어지고 변경이 일어날 때 마다 큰 공수가 들어가게 된다.

### 중복 코드의 메소드 추출, 변경사항에 대한 검증 : 리팩토링과 테스트
가장 먼저 중복된 코드를 분리하여 별도의 메소드로 추출한다.

1. DB와 연결을 위한 커넥션을 어떻게 가져올까?

해당 관심에 관련된 변경이 일어났을 경우, 관심이 집중된 메소드(`getConnection()`)만 수정하면 간단히 변경 가능하다.
> DB 종류, 로그인 정보, 접속 방법 등의 변경


코드를 수정한 후에는 기능에 문제가 없다는 것이 절대 보장되지 않는다. 반드시 다시 검증이 필요하다.  
어떻게 검증할 수 있을까?
-> 기존 테이블의 데이터를 삭제한 뒤 `main()` 메소드를 이용한 테스트를 실행하여 이전 결과와 동일한 결과가 출력되는지 확인한다.

기능에는 아무런 변화가 없지만, 여러 메소드에 중복돼서 등장하는 특정 관심사항이 담긴 코드를 별도의 메소드로 분리했다. 이전보다 훨씬 깔끔해졌고, 미래의 변화에 좀 더 손쉽게 대응할 수 있는 코드가 되었다.
-> 이러한 공통의 기능을 담당하는 메소드로 중복된 코드를 뽑아내는 것을 리팩토링에서는 **메소드 추출** 기법이라고 부른다.


## 1.2.3 DB 커넥션 만들기의 독립

DB 커넥션을 가져오는 데 있어서 다양한 방법으로 각각 구현하고자 하는 니즈가 있을 때 어떻게 대비를 해야할까?


### 상속을 통한 확장

추상 클래스를 만들어 `getConnection()` 메소드를 원하는 방식으로 구현하게 한다.

상속을 이용하면 `UserDao` 소스를 제공하지 않아도 원하는 방식으로 **확장** 한 후 `UserDao`의 기능과 함께 사용할 수 있다.

클래스 계층 구조를 통해 두 개의 관심이 독립적으로 분리되면서 **변경** 작업은 용이해졌고,
`UserDao` 코드는 한 줄도 수정할 필요 없이 DB 연결 기능을 새롭게 정의한 클래스를 만들 수 있어 손쉽게 **확장** 된다.

이렇게 슈퍼클래스의 기본적인 로직의 흐름을 만들고 그 기능의 일부를 추상 메소드나 오버라이딩이 가능한 protected 메소드 등으로 만든 뒤 서브클래스에서 이런 메소드를 필요에 맞게 구현해서 사용하도록 하는 방법을 **템플릿 메소드 패턴** 이라고 한다.

`getConnection()` 메소드는 `Connection` 타입 오브젝트를 생성하는 기능을 정의해놓은 추상 메소드로, 어떤 `Connection` 클래스의 오브젝트를 어떻게 생성할 것인지를 결정하는 방법이라고도 볼 수 있다. 이렇게 서브클래스에서 구체적인 오브젝트 생성 방법을 결정하게 하는 것을 **팩토리 메소드 패턴** 이라고 한다.   

  > `getConnection()` 메소드에서 생성하는 `Connection` 오브젝트의 구현 클래스는 제각각이겠지만, `UserDao`는 `Connection` 인터페이스 타입의 오브젝트라는 것 외에는 관심을 두지 않는다. 그저 정의된 메소드를 사용할 뿐이다. 즉 어떤 방법으로 Connection 오브젝트를 만들어내는지도 `UserDao` 구현체들의 관심사항이지, `UserDao`의 관심사가 아니다.

이렇게 템플릿 메소드 패턴 또는 팩토리 메소드 페턴으로 관심사항이 다른 코드를 분리해내고, 서로 독립적으로 변경 또는 확장할 수 있도록 만드는 것은 간단하면서도 매우 효과적이다.


하지만, **상속** 을 이용했다는 단점이 있다.
- 만약 `UserDao`가 다른 목적을 위해 상속을 사용하고 있다면?
  - 단지 커넥션 객체를 가져오는 방법을 분리하기 위해 상속구조로 만들어버리면, 후에 다른 목적으로 `UserDao`에 상속을 적용하기 힘들다.
- 서브클래스는 슈퍼클래스의 기능을 직접 사용할 수 있는데, 슈퍼클래스의 내부 변경으로 모든 서브클래스를 함께 수정해야 한다면?
  - 상속을 통한 상하위 클래스의 관계는 밀접하여, 슈퍼클래스가 더 이상 변화하지 않도록 제약을 가해야 할지도 모른다.
- 확장된 기능인 DB 커넥션을 생성하는 코드를 다른 DAO에는 적용해야 한다면?
  - `UserDao` 외의 DAO 클래스가 만들어진다면, 그때는 상속을 통해 만들어진 `getConnection()`의 구현 코드가 매 DAO 클래스마다 중복돼서 나타날 것이다.



# DAO의 확장

데이터 액세스 로직을 어떻게 만들 것인가(1)와 DB 연결을 어떤 방법으로 할 것인가(2)라는 두 개의 관심을 상하위 클래스로 분리시켰다.

추상클래스를 만들고 이를 상속한 서브클래스에서 변화가 필요한 부분을 바꿔서 쓸 수 있게 만든 이유는 이 두 개의 관심은 변화의 성격이 다르기 때문에 서로 영향을 주지 않은 채로 독립적으로 변경할 수 있게 하기 위해서다.



## 1.3.1 클래스의 분리

두 개의 관심사를 본격적으로 독립시키면서 동시에 손쉽게 확장할 수 있는 방법을 알아보자.

> 독립된 메소드로 분리 -> 상하위 클래스로 분리 -> 완전히 독립적인 클래스로 분리

`SimpleConnectionMaker`는 DB 커넥션 생성 기능을 독립시켰다.

하지만 DB 커넥션 기능을 확장해서 사용하게 했던 게 다시 불가능해졌다. `UserDao`의 코드가 `SimpleConnectionMaker`라는 특정 클래스에 종속되어 있기 때문에 상속을 사용했을 떄처럼 `UserDao` 코드의 수정 없이 DB 커넥션 생성 기능을 변경할 방법이 없다.

첫번째는 클래스를 분리한 경우에도 자유로운 확장이 가능하게 하려면 두 가지 문제를 해결해야 한다.  
DB 커넥션 구현 방법에 따라 메소드 이름이 다를 수 있어, `add()`, `get()` 메소드의 커넥션을 가져오는 코드를 일일이 변경해야 한다.

두번째는 DB 커넥션을 제공하는 클래스가 어떤 것인지 `UserDao`가 구체적으로 알고 있어야 한다는 점이다. `SimpleConnectionMaker`라는 클래스타입의 인스턴스 변수까지 정의해놓고 있으니, 다른 클래스를 구현하면 `UserDao` 자체를 다시 수정해야 한다.

이런 문제의 근본적인 원인은 `UserDao`가 바뀔 수 있는 정보, 즉 DB 커넥션을 가져오는 클래스에 대해 너무 많이 알고 있기 때문이다. `UserDao`는 DB 커넥션을 가져오는 구체적인 방법에 종속되어 버리기 때문에 앞으로 DB 커넥션을 가져오는 방법을 자유롭게 확장하기가 힘들어졌다.

## 1.3.2 인터페이스의 도입

클래스를 분리하면서도 확장하기 어려워진 문제를 어떻게 해결할까?  
해결책은 두 개의 클래스가 서로 긴밀하게 연결되어 있지 않도록 중간에 추상적인 연결고리를 만들어주는 것이고, 자바가 추상화를 위해 제공하는 가장 유용한 도구는 바로 **인터페이스** 다.

> 추상화 : 공통적인 성격을 뽑아내어 이를 따로 분리하는 것

**인터페이스** 는 어떤 일을 하겠다는 기능만 정의해놓은 것으로, 어떻게 하겠다는 구현 방법은 나타나 있지 않다. 그것은 인터페이스를 구현한 클래스들이 알아서 결정할 일이다.  
`UserDao`에서 인터페이스를 사용하게 한다면 인터페이스의 메소드를 통해 알 수 있는 기능에만 관심을 가지면 되지, 그 기능을 어떻게 구현했는지에는 관심을 둘 필요가 없다.

`UserDao`의 `add()`, `get()`메소드와 필드에는 `ConnectionMaker`라는 인터페이스와 인터페이스의 메소드인 `makeConnection()`만 사용하게 했다. 하지만 초기에 한 번 어떤 클래스의 오브젝트를 사용할지를 결정하는 생성자의 코드는 제거되지 않고 남아 있다.


## 1.3.3 관계설정 책임의 분리

왜 `UserDao`에는 인터페이스 뿐만 아니라 구체적인 클래스까지 알아야 한다는 문제가 발생하는 걸까? 그 이유는 `UserDao`에는 어떤 `ConnectionMaker` 구현 클래스를 사용할지를 결정하는 코드가 남아 있다. 즉, `UserDao`안에 분리되지 않은, 또 다른 관심사항이 남아있다.

간단히 말하자면, `UserDao`와 `UserDao`가 사용할 `ConnectionMaker`의 특정 구현 클래스 사이의 관계를 설정해주는 것에 관한 관심이 짧은 코드 안에 있다. 이 관심사를 분리하지 않으면 결코 독립적으로 확장 가능한 클래스가 될 수 없다.

```java
// 어떤 ConnectionMaker 구현 클래스의 오브젝트를 이용하게 할지?

connectionMaker = new DConnectionMaker();
```

`UserDao` 클라이언트에서 `UserDao`를 사용하기 전에, `UserDao`가 어떤 `ConnectionMaker`의 구현 클래스를 사용할지를 결정하도록 만들어보자.
즉 `UserDao` 오브젝트와 특정 클래스로부터 만들어진 `ConnectionMaker` 오브젝트 사이의 관계를 설정해주는 것이다.

오브젝트 사이의 관계는 런타임 시 한 쪽이 다른 오브젝트의 레퍼런스를 갖고 있는 방식으로 만들어진다.
```java
// 레퍼런스, ConnectionMaker중 DConnectionMaker를 사용한다.
connectionMaker = new DConnectionMaker();
```

외부에서 만든 오브젝트를 전달받으려면 메소드 파라미터나 생성자 파라미터를 사용하여 전달받는다. 이 때, 파라미터 타입을 전달받을 오브젝트의 인터페이스로 선언해뒀다고 하면 해당 인터페이스를 구현하기만 하면 어떤 인스턴스든 상관 없다. 인터페이스에 정의된 메소드만 이용한다면 그 오브젝트가 어떤 클래스로부터 만들어졌는지 신경쓰지 않아도 된다.


오브젝트 사이에 다이나믹한 관계가 맺어지는 것이지, 클래스 사이에 관계가 만들어지는 것은 아니다. 다형성의 특징중 하나로, 코드에서 특정 클래스를 전혀 알지 못하더라도 해당 클래스가 구현한 인터페이스를 사용했다면 그 클래스의 오브젝트를 인터페이스 타입으로 받아서 사용할 수 있다.

그래서 `UserDao` 오브젝트가 `DConnectionMaker` 오브젝트를 사용하게 하려면 두 클래스 오브젝트 사이에 런타임 사용관계 또는 링크, 또는 의존관계라고 불리는 관계를 맺어주면 된다.

그렇다면 `UserDao`의 클라이언트는 무슨 역할을 할까?
-> 바로 런타임 오브젝트 관계를 갖는 구조를 만들어주는 게 바로 클라이언트의 책임이다.

클라이언트는 `UserDao`를 사용해야 할 입장이기 때문에 `UserDao`의 세부 전략이라고도 볼 수 있는 `ConnectionMaker`의 구현 클래스를 선택하고, 선택한 클래스의 오브젝트를 생성해서 `UserDao`와 연결해줄 수 있다.

> 이것은 `UserDao`의 관심도 아니고 책임도 아니다 !

현재는 `main()` 메소드가 `UserDao`의 클라이언트이다. `UserDao`의 생성자를 추가해서 클라이언트가 미리 만들어둔 `ConnectionMaker`를 전달받을 수 있도록 만들자.

`main()` 메소드는 `UserDaoTest` 클래스 내 메소드로 만들어졌고, `UserDao`와 `ConnectionMaker` 구현 클래스와의 런타임 오브젝트 의존관게를 설정하는 책임을 담당해야 한다. 그리고 원래 자기 책임이던 `UserDao`에 대한 테스트 작업을 수행한다.

`UserDao`는 다른 관심사가 함께 있어 확장성을 떨어뜨리는 문제를 해결했다. 더 이상 DB 생성 방법이나 전략에 대해서는 조금도 고민할 필요가 없다. DB 커넥션을 가져오는 방법을 어떻게 변경하든 `UserDao`는 아무런 영향을 받지 않는다.

인터페이스를 사용함으로써, 상속을 사용했을 때보다 훨씬 유연해졌다.


## 1.3.4 원칙과 패턴

### 개방 폐쇄 원칙(OCP - Open-Closed Principle)
클래스나 모듈은 확장에는 열려 있어야 하고 변경에는 닫혀 있어야 한다.

`UserDao`는 DB 연결 방법이라는 기능을 확장하는 데에는 열려있지만, 자신의 핵심 기능을 구현한 코드에는 해당 기능에 대한 변화에 영향을 받지 않고 유지할 수 있어서 변경에는 닫혀있다.

### 높은 응집도와 낮은 결합도

**응집도가 높다** : 하나의 모듈, 클래스가 하나의 책임 또는 관심사에만 집중되어 있다.
변경이 일어날 때 모듈의 많은 부분이 함께 바뀐다면 응집도가 높다고 말할 수 있다.  


**결합도가 낮다** : 책임과 관심사가 다른 오브젝트 또는 모듈과는 느슨하게 연결된 형태를 유지하는 것이 바람직하다.
느슨한 연결은 관계를 유지하는 데 꼭 필요한 최소한의 방법만 간접적인 형태로 제공하고, 나머지는 서로 독립적이고 알 필요도 없게 만들어주는 것이다.

> 결합도 : 하나의 오브젝트가 변경이 일어날 때에 관계를 맺고 있는 다른 오브젝트에게 변화를 요구하는 정도


`UserDao`는 자체로 자신의 책임에 대한 응집도가 높다. 사용자의 데이터를 처리하는 기능이 흩어져있지 않고 DAO 안에 이해하기 쉽고, 깔끔하게 모여있다.

동시에 `UserDao`와 `ConnectionMaker`의 관계는 인터페이스를 통해 매우 느슨하게 연결되어 있다. `UserDao`는 구체적인 `ConnectionMaker`구현 클래스를 알 필요도 없고, 뒤에 사용하는 또 다른 오브젝트에 대해서도 신경쓰지 않아도 된다.

## # 전략 패턴

자신의 기능 맥락에서, 필요에 따라 변경이 필요한 알고리즘 클래스를 필요에 따라 바꿔서 사용할 수 있게 하는 디자인 패턴이다.

`UserDao`는 전략 패턴의 컨텍스트에 해당한다. `UserDao`(컨텐스트)는 자신의 기능을 수행하는데 필요한 기능 중에서 변경 가능한 DB 연결 방식(알고리즘)을 `ConnectionMaker`라는 인터페이스로 정의하고, 이를 구현한 클래스(전략)를 바꿔가면서 사용할 수 있게 분리했다.

`UserDaoTest`와 같은 클라이언트는 `UserDao`(컨텍스트)가 사용할 `ConnectionMaker`(전략)을 생성자 등을 통해 제공해주는 게 일반적이다.




























# 참고
- mysql timezone 설정
https://jwkim96.tistory.com/23
- mysql connector
https://dev.mysql.com/downloads/connector/j/
- mysql 계정 설정
https://linuxize.com/post/how-to-change-mysql-user-password/
