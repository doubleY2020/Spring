스프링은
- 자바가 객체지향 프로그래밍이 가능한 언어라는 점을 가장 중요하게 가치를 둔다.
- 그래서 오브젝트를 어떻게 효과적으로 설계, 구현, 사용, 개선할 것인가에 대한 기준을 마련해준다.
- 동시에 객체지향 기술과 설계, 구현에 관한 실용적인 전략과 검증된 베스트 프랙티스를 쉽게 적용할 수 있도록 프레임 워크 형태로 제공한다.




# 1.1 초난감 DAO

> DAO : Data Access Object
> DB를 사용해 데이터를 조회하거나 조작하는 기능을 전담

## 1.1.1~2 User, UserDao

> 자바 빈 : 다음의 두 관례를 따라 만들어진 오브젝트를 가르킨다
> 디폴트 생성자를 가진다. (리플렉션을 이용하여 오브젝트를 생성하기 때문)
> 프로퍼티를 가지고, 접근자(getter)와 수정자(setter)가 존재한다.  


`UserDao` 클래스가 동작하는지 어떻게 알 수 있을까?
 - 웹 애플리케이션을 만들어 서버에 배치하고, 웹 브라우저를 통해 DAO 기능을 테스트한다.
    - 배보다 배꼽이 크다.

## 1.1.3 main()을 이용한 DAO 테스트 코드
코드의 기능 검증을 위한 방법으로 자신을 엔트리 포인트로 설정해 직접 실행이 가능하게 해주는 스태틱 메소드(`main()`)를 사용한다.



현재의 `UserDao`는 왜 코드에 문제가 많다고 하는 것일까?
잘 동작하는 코드를 굳이 수정하고 개선해야 하는 이유는 뭘까?
개선했을 때의 단기적/장기적 장점은 무엇일까?
객체지향 설계의 원칙과 무슨 상관이 있을까?
개선하는 경우와 그대로 사용하는 경우, 스프링을 사용하는 개발에서는 무슨 차이가 있을까?


# 1.2 DAO의 분리

## 1.2.1 관심사의 분리
소프트웨어 개발에서 요구사항은 끊임없이 바뀌고 발전한다. 그에 따라 오브젝트에 대한 설계와 이를 구현한 코드 역시 변한다.
그러므로 개발자가 객체를 설계할 때 가장 염두에 둬야 할 것은 미래의 **변화** 를 어떻게 대비할 것인가이다,

객체지향 설계와 프로그래밍은 변화에 효과적으로 대처할 수 있다는 기술적인 특징이 있다.  
실세계에 최대한 가깝게 모델링해낼 수 있기 때문이기도 하고
가상의 추상세계 자체를 효과적으로 구상할 수 있으며,
이를 자유롭고 편리하게 변경, 발전, 확장시킬 수 있다는 데 더 큰 의미가 있다.

그렇다면 변화에 어떻게 대비할 것인가 ?
-> **변화의 폭을 최소한 줄여주는 것** 이 가장 좋은 대책이다.

**어떻게 변경이 일어날 때 필요한 작업을 최소화하고, 그 변경이 다른 곳에 문제를 일으키지 않게 할 수 있을까?**  
: 분리와 확장을 고려한 설계가 필요하다.



> **변화**(미래) 대응법 : **분리** 와 **확장** 을 고려한 설계

변화가 한 가지 관심에 집중돼서 일어난다면 우리는 한가지 관심이 한 군데에 집중되게 한다.  
즉 관심이 같은 것끼리는 모으고, 관심이 다른 것은 따로 떨어져 있게 하는 것이다.

관심사가 같은 것끼리 모으고 다른 것은 분리해줌으로써 같은 관심에 효과적으로 집중할 수 있게 만들어주는 것이다.

## 1.2.2 커넥션 만들기의 추출

`UserDao`에서는 세 가지 관심사항을 발견할 수 있다.

  1. DB와 연결을 위한 커넥션을 어떻게 가져올까?
  2. DB에 보낼 SPL 문장을 담은 Statement를 어떻게 만들고 실행할까?
  3. 사용 완료한 공유 자원(Statement, Connection 오브젝트)를 어떻게 시스템에 반환할까?

가장 문제가 되는 부분은 1번이 `add()` 메소드와 `get()` 메소드에 각각 중복으로 구현되어 있다는 것이다. 이는 DAO 내 메소드가 많아지면 많아질 수록 같은 관심에 대해서 수정 범위가 넓어지고 변경이 일어날 때 마다 큰 공수가 들어가게 된다.

### 중복 코드의 메소드 추출, 변경사항에 대한 검증 : 리팩토링과 테스트
가장 먼저 중복된 코드를 분리하여 별도의 메소드로 추출한다.

> 1. DB와 연결을 위한 커넥션을 어떻게 가져올까?

해당 관심에 관련된 변경이 일어났을 경우, 관심이 집중된 메소드(`getConnection()`)만 수정하면 간단히 변경 가능하다.
> 예) DB 종류, 로그인 정보, 접속 방법 등의 변경


코드를 수정한 후에는 기능에 문제가 없다는 것이 절대 보장되지 않는다. 반드시 다시 검증이 필요하다.  

어떻게 검증할 수 있을까?  
-> 기존 테이블의 데이터를 삭제한 뒤 `main()` 메소드를 이용한 테스트를 실행하여 이전 결과와 동일한 결과가 출력되는지 확인한다.

기능에는 아무런 변화가 없지만, 여러 메소드에 중복돼서 등장하는 특정 관심사항이 담긴 코드를 별도의 메소드로 분리했다. 이전보다 훨씬 깔끔해졌고, 미래의 변화에 좀 더 손쉽게 대응할 수 있는 코드가 되었다.  
-> 이러한 공통의 기능을 담당하는 메소드로 중복된 코드를 뽑아내는 것을 리팩토링에서는 **메소드 추출** 기법이라고 부른다.


## 1.2.3 DB 커넥션 만들기의 독립

DB 커넥션을 가져오는 데 있어서 다양한 방법으로 각각 구현하고자 하는 니즈가 있을 때 어떻게 대비를 해야할까?


### 상속을 통한 확장

추상 클래스를 만들어 `getConnection()` 메소드를 원하는 방식으로 구현하게 한다.

상속을 이용하면 `UserDao` 소스를 제공하지 않아도 원하는 방식으로 **확장** 한 후 `UserDao`의 기능과 함께 사용할 수 있다.

클래스 계층 구조를 통해 두 개의 관심이 독립적으로 분리되면서 **변경** 작업은 용이해졌고,
`UserDao` 코드는 한 줄도 수정할 필요 없이 DB 연결 기능을 새롭게 정의한 클래스를 만들 수 있어 손쉽게 **확장** 가능하 .

이렇게 슈퍼클래스의 기본적인 로직의 흐름을 만들고 그 기능의 일부를 추상 메소드나 오버라이딩이 가능한 protected 메소드 등으로 만든 뒤 서브클래스에서 이런 메소드를 필요에 맞게 구현해서 사용하도록 하는 방법을 **템플릿 메소드 패턴** 이라고 한다.

`getConnection()` 메소드는 `Connection` 타입 오브젝트를 생성하는 기능을 정의해놓은 추상 메소드로, 어떤 `Connection` 클래스의 오브젝트를 어떻게 생성할 것인지를 결정하는 방법이라고도 볼 수 있다.  
이렇게 서브클래스에서 구체적인 오브젝트 생성 방법을 결정하게 하는 것을 **팩토리 메소드 패턴** 이라고 한다.   

  > `getConnection()` 메소드에서 생성하는 `Connection` 오브젝트의 구현 클래스는 제각각이겠지만, `UserDao`는 `Connection` 인터페이스 타입의 오브젝트라는 것 외에는 관심을 두지 않는다. 그저 정의된 메소드를 사용할 뿐이다. 즉 어떤 방법으로 Connection 오브젝트를 만들어내는지도 `UserDao` 구현체들의 관심사항이지, `UserDao`의 관심사가 아니다.

이렇게 템플릿 메소드 패턴 또는 팩토리 메소드 페턴으로 관심사항이 다른 코드를 분리해내고, 서로 독립적으로 변경 또는 확장할 수 있도록 만드는 것은 간단하면서도 매우 효과적이다.


하지만, **상속** 을 이용했다는 단점이 있다.
- 만약 `UserDao`가 다른 목적을 위해 상속을 사용하고 있다면?
  - 단지 커넥션 객체를 가져오는 방법을 분리하기 위해 상속구조로 만들어버리면, 후에 다른 목적으로 `UserDao`에 상속을 적용하기 힘들다.
- 서브클래스는 슈퍼클래스의 기능을 직접 사용할 수 있는데, 슈퍼클래스의 내부 변경으로 모든 서브클래스를 함께 수정해야 한다면?
  - 상속을 통한 상하위 클래스의 관계는 밀접하여, 슈퍼클래스가 더 이상 변화하지 않도록 제약을 가해야 할지도 모른다.
- 확장된 기능인 DB 커넥션을 생성하는 코드를 다른 DAO에는 적용해야 한다면?
  - `UserDao` 외의 DAO 클래스가 만들어진다면, 그때는 상속을 통해 만들어진 `getConnection()`의 구현 코드가 매 DAO 클래스마다 중복돼서 나타날 것이다.



# DAO의 확장

데이터 액세스 로직을 어떻게 만들 것인가(1)와 DB 연결을 어떤 방법으로 할 것인가(2)라는 두 개의 관심을 상하위 클래스로 분리시켰다.

추상클래스를 만들고 이를 상속한 서브클래스에서 변화가 필요한 부분을 바꿔서 쓸 수 있게 만든 이유는 이 두 개의 관심은 변화의 성격이 다르기 때문에 서로 영향을 주지 않은 채로 독립적으로 변경할 수 있게 하기 위해서다.



## 1.3.1 클래스의 분리

두 개의 관심사를 본격적으로 독립시키면서 동시에 손쉽게 확장할 수 있는 방법을 알아보자.

> 독립된 메소드로 분리 -> 상하위 클래스로 분리 -> 완전히 독립적인 클래스로 분리

`SimpleConnectionMaker`는 DB 커넥션 생성 기능을 독립시켰다.

하지만 DB 커넥션 기능을 확장해서 사용하게 했던 게 다시 불가능해졌다. `UserDao`의 코드가 `SimpleConnectionMaker`라는 특정 클래스에 종속되어 있기 때문에 상속을 사용했을 떄처럼 `UserDao` 코드의 수정 없이 DB 커넥션 생성 기능을 변경할 방법이 없다.

**첫번째** 는 클래스를 분리한 경우에도 자유로운 확장이 가능하게 하려면 두 가지 문제를 해결해야 한다.  
DB 커넥션 구현 방법에 따라 메소드 이름이 다를 수 있어, `add()`, `get()` 메소드의 커넥션을 가져오는 코드를 일일이 변경해야 한다.

**두번째** 는 DB 커넥션을 제공하는 클래스가 어떤 것인지 `UserDao`가 구체적으로 알고 있어야 한다는 점이다. `SimpleConnectionMaker`라는 클래스타입의 인스턴스 변수까지 정의해놓고 있으니, 다른 클래스를 구현하면 `UserDao` 자체를 다시 수정해야 한다.

이런 문제의 근본적인 원인은 `UserDao`가 바뀔 수 있는 정보, 즉 DB 커넥션을 가져오는 클래스에 대해 너무 많이 알고 있기 때문이다. `UserDao`는 DB 커넥션을 가져오는 구체적인 방법에 종속되어 버리기 때문에 앞으로 DB 커넥션을 가져오는 방법을 자유롭게 확장하기가 힘들어졌다.

## 1.3.2 인터페이스의 도입

클래스를 분리하면서도 확장하기 어려워진 문제를 어떻게 해결할까?  
해결책은 두 개의 클래스가 서로 긴밀하게 연결되어 있지 않도록 중간에 추상적인 연결고리를 만들어주는 것이고, 자바가 추상화를 위해 제공하는 가장 유용한 도구는 바로 **인터페이스** 이다.

> 추상화 : 공통적인 성격을 뽑아내어 이를 따로 분리하는 것

**인터페이스** 는 어떤 일을 하겠다는 기능만 정의해놓은 것으로, 어떻게 하겠다는 구현 방법은 나타나 있지 않다. 그것은 인터페이스를 구현한 클래스들이 알아서 결정할 일이다.  
`UserDao`에서 인터페이스를 사용하게 한다면 인터페이스의 메소드를 통해 알 수 있는 기능에만 관심을 가지면 되지, 그 기능을 어떻게 구현했는지에는 관심을 둘 필요가 없다.

`UserDao`의 `add()`, `get()`메소드와 필드에는 `ConnectionMaker`라는 인터페이스와 인터페이스의 메소드인 `makeConnection()`만 사용하게 했다. 하지만 초기에 한 번 어떤 클래스의 오브젝트를 사용할지를 결정하는 생성자의 코드는 제거되지 않고 남아 있다.


## 1.3.3 관계설정 책임의 분리

왜 `UserDao`에는 인터페이스 뿐만 아니라 구체적인 클래스까지 알아야 한다는 문제가 발생하는 걸까? 그 이유는 `UserDao`에는 어떤 `ConnectionMaker` 구현 클래스를 사용할지를 결정하는 코드가 남아 있다. 즉, `UserDao`안에 분리되지 않은, 또 다른 관심사항이 남아있다.

간단히 말하자면, `UserDao`와 `UserDao`가 사용할 `ConnectionMaker`의 특정 구현 클래스 사이의 관계를 설정해주는 것에 관한 관심이 짧은 코드 안에 있다. 이 관심사를 분리하지 않으면 결코 독립적으로 확장 가능한 클래스가 될 수 없다.

```java
// 어떤 ConnectionMaker 구현 클래스의 오브젝트를 이용하게 할지?

connectionMaker = new DConnectionMaker();
```

`UserDao` 클라이언트에서 `UserDao`를 사용하기 전에, `UserDao`가 어떤 `ConnectionMaker`의 구현 클래스를 사용할지를 결정하도록 만들어보자.
즉 `UserDao` 오브젝트와 특정 클래스로부터 만들어진 `ConnectionMaker` 오브젝트 사이의 관계를 설정해주는 것이다.

오브젝트 사이의 관계는 런타임 시 한 쪽이 다른 오브젝트의 레퍼런스를 갖고 있는 방식으로 만들어진다.
```java
// 레퍼런스, ConnectionMaker중 DConnectionMaker를 사용한다.
connectionMaker = new DConnectionMaker();
```

외부에서 만든 오브젝트를 전달받으려면 메소드 파라미터나 생성자 파라미터를 사용하여 전달받는다. 이 때, 파라미터 타입을 전달받을 오브젝트의 인터페이스로 선언해뒀다고 하면 해당 인터페이스를 구현하기만 하면 어떤 인스턴스든 상관 없다. 인터페이스에 정의된 메소드만 이용한다면 그 오브젝트가 어떤 클래스로부터 만들어졌는지 신경쓰지 않아도 된다.


오브젝트 사이에 다이나믹한 관계가 맺어지는 것이지, 클래스 사이에 관계가 만들어지는 것은 아니다. 다형성의 특징중 하나로, 코드에서 특정 클래스를 전혀 알지 못하더라도 해당 클래스가 구현한 인터페이스를 사용했다면 그 클래스의 오브젝트를 인터페이스 타입으로 받아서 사용할 수 있다.

그래서 `UserDao` 오브젝트가 `DConnectionMaker` 오브젝트를 사용하게 하려면 두 클래스 오브젝트 사이에 런타임 사용관계 또는 링크, 또는 의존관계라고 불리는 관계를 맺어주면 된다.

그렇다면 `UserDao`의 클라이언트는 무슨 역할을 할까?  
-> 바로 런타임 오브젝트 관계를 갖는 구조를 만들어주는 게 바로 클라이언트의 책임이다.

클라이언트는 `UserDao`를 사용해야 할 입장이기 때문에 `UserDao`의 세부 전략이라고도 볼 수 있는 `ConnectionMaker`의 구현 클래스를 선택하고, 선택한 클래스의 오브젝트를 생성해서 `UserDao`와 연결해줄 수 있다.

> 이것은 `UserDao`의 관심도 아니고 책임도 아니다 !

현재는 `main()` 메소드가 `UserDao`의 클라이언트이다. `UserDao`의 생성자를 추가해서 클라이언트가 미리 만들어둔 `ConnectionMaker`를 전달받을 수 있도록 만들자.

`main()` 메소드는 `UserDaoTest` 클래스 내 메소드로 만들어졌고, `UserDao`와 `ConnectionMaker` 구현 클래스와의 런타임 오브젝트 의존관게를 설정하는 책임을 담당해야 한다. 그리고 원래 자기 책임이던 `UserDao`에 대한 테스트 작업을 수행한다.

`UserDao`는 다른 관심사가 함께 있어 확장성을 떨어뜨리는 문제를 해결했다. 더 이상 DB 생성 방법이나 전략에 대해서는 조금도 고민할 필요가 없다. DB 커넥션을 가져오는 방법을 어떻게 변경하든 `UserDao`는 아무런 영향을 받지 않는다.

인터페이스를 사용함으로써, 상속을 사용했을 때보다 훨씬 유연해졌다.


## 1.3.4 원칙과 패턴

### 개방 폐쇄 원칙(OCP - Open-Closed Principle)
클래스나 모듈은 확장에는 열려 있어야 하고 변경에는 닫혀 있어야 한다.

`UserDao`는 DB 연결 방법이라는 기능을 확장하는 데에는 열려있지만, 자신의 핵심 기능을 구현한 코드에는 해당 기능에 대한 변화에 영향을 받지 않고 유지할 수 있어서 변경에는 닫혀있다.

### 높은 응집도와 낮은 결합도

**응집도가 높다** : 하나의 모듈, 클래스가 하나의 책임 또는 관심사에만 집중되어 있다.
변경이 일어날 때 모듈의 많은 부분이 함께 바뀐다면 응집도가 높다고 말할 수 있다.  


**결합도가 낮다** : 책임과 관심사가 다른 오브젝트 또는 모듈과는 느슨하게 연결된 형태를 유지하는 것이 바람직하다.
느슨한 연결은 관계를 유지하는 데 꼭 필요한 최소한의 방법만 간접적인 형태로 제공하고, 나머지는 서로 독립적이고 알 필요도 없게 만들어주는 것이다.

> 결합도 : 하나의 오브젝트가 변경이 일어날 때에 관계를 맺고 있는 다른 오브젝트에게 변화를 요구하는 정도


`UserDao`는 자체로 자신의 책임에 대한 응집도가 높다. 사용자의 데이터를 처리하는 기능이 흩어져있지 않고 DAO 안에 이해하기 쉽고, 깔끔하게 모여있다.

동시에 `UserDao`와 `ConnectionMaker`의 관계는 인터페이스를 통해 매우 느슨하게 연결되어 있다. `UserDao`는 구체적인 `ConnectionMaker`구현 클래스를 알 필요도 없고, 뒤에 사용하는 또 다른 오브젝트에 대해서도 신경쓰지 않아도 된다.

### 전략 패턴

자신의 기능 맥락에서, 필요에 따라 변경이 필요한 알고리즘 클래스를 필요에 따라 바꿔서 사용할 수 있게 하는 디자인 패턴이다.

`UserDao`는 전략 패턴의 컨텍스트에 해당한다. `UserDao`(컨텐스트)는 자신의 기능을 수행하는데 필요한 기능 중에서 변경 가능한 DB 연결 방식(알고리즘)을 `ConnectionMaker`라는 인터페이스로 정의하고, 이를 구현한 클래스(전략)를 바꿔가면서 사용할 수 있게 분리했다.

`UserDaoTest`와 같은 클라이언트는 `UserDao`(컨텍스트)가 사용할 `ConnectionMaker`(전략)을 생성자 등을 통해 제공해주는 게 일반적이다.


# 1.4 제어의 역전(IoC)

> IoC : Injection of Control

## 1.4.1 오브젝트 팩토리

`UserDaoTest`는 본래 `UserDao`의 기능이 잘 동작하는지를 테스트하려고 만든 것이다. 그런데 지금은 어떤 `ConnectionMaker` 구현 클래스를 사용할지를 결정하는 기능을 떠맡았다.  
성격이 다른 책임이나 관심사는 분리해버리는 것이 지금까지 해왔던 주요한 작업이므로, 이 또한 분리하자.

- `UserDao`와 `ConnectionMaker` 구현 클래스의 오브젝트를 만드는 것
- 그래서 두 개의 오브젝트가 연결돼서 사용될 수 있도록 관계를 맺어주는 것


### 팩토리
분리시킬 기능을 담당할 클래스는 객체의 생성 방법을 결정하고 그렇게 만들어진 오브젝트를 돌려주는 팩토리이다.
오브젝트를 생성하는 쪽과 생성된 오브젝트를 사용하는 쪽의 역할과 책임을 깔끔하게 분리하기 위해서이다.


`UserDaoTest`는 `UserDao`가 어떻게 만들어지는지 어떻게 초기화되어 있는지에 신경쓰지 않고 `DaoFactory` 팩토리로부터 `UserDao` 오브젝트를 받아다가, 자신의 관심사인 테스트를 위해 활용하기만 하면 된다.

### 설계도로서의 팩토리
`UserDao`와 `ConnectionMaker`는 각각 애플리케이션의 핵심적인 데이터 로직과 기술 로직을 담당하고 있고(실질적인 로직을 담당), `DaoFactory`는 이런 애플리케이션의 오브젝트들을 구성하고 그 관계를 정의하는 책임(컴포넌트 구조 관계를 정의한 설계도)을 맡고 있음을 알 수 있다.

새로운 `ConnectionMaker` 구현 클래스로 변경이 필요하면 `DaoFactory`를 수정해서 변경된 클래스를 생성해 설정해주도록 코드를 수정해주면 된다. 여전히 `UserDao`는 변경이 필요 없고, DB 연결 방식은 자유로운 확장이 가능하다.

`DaoFactory`를 분리했을 때 얻을 수 있는 장점은 다양한데, 그 중 가장 큰 장점은 애플리케이션의 컴포넌트 역할을 하는 오브젝트(`UserDao`, `ConnectionMaker`)와 애플리케이션의 구조를 결정하는 오브젝트(`DaoFactory`)를 분리했다는 데 가장 의미가 있다.




## 1.4.2 오브젝트 팩토리의 활용

`DaoFactory`에 `UserDao`가 아닌 다른 DAO의 생성 기능을 넣으면 어떻게 될까?

단순히 `userDao()` 메소드를 복사해서 `accountDao()`, `messageDao()`를 만들다면 모두 `new DConnectionMaker()`라는 구현 클래스의 인스턴스를 만드는 부분이 반복돼서 나타난다. 오브젝트 생성 코드가 중복되는 것은 변경에 취약하여 좋지 않은 현상이다.

그러므로 오브젝트를 만드는 코드를 별도의 메소드로 뽑아내고(`getConnection()`), 각 DAO 생성용 메소드에서는 `ConnectionMaker` 생성용 메소드를 이용하도록 수정한다. 이렇게 해두면 DAO 팩토리 메소드가 많아져도 `ConnectionMaker`의 구현 클래스를 바꿀 때 딱 한 부분만 수정하면 된다.


## 1.4.3 제어권의 이전을 통한 제어관계 역전

제어의 역전 : 프로그램의 제어 흐름 구조가 뒤바뀌는 것

이전의 `main()` 메소드는 `UserDao` 클래스의 오브젝트를 직접 생성하고, 만들어진 오브젝트의 메소드를 사용한다. `UserDao` 또한 자신이 사용할 `ConnectionMaker`의 구현 클래스를 자신이 결정하고, 필요한 시점에 생성해두어 각 메소드에서 이를 사용한다. 모든 오브젝트가 능동적으로 자신이 사용할 클래스를 결정하고 언제 그 오브젝트를 만들지를 스스로 관장한다. 모든 종류의 작업을 사용하는 쪽에서 제어하는 구조이다.

제어의 역전(**IoC**)에서는 *오브젝트가 자신이 사용할 오브젝트를 스스로 선택하지 않는다.* 또한 *어떻게 만들어지고 어디서 사용되는지를 알 수 없다.* *모든 제어 권한은 다른 대상에게 위임* 하기 때문이다.

초기 템플릿 메소드 패턴에서, 추상 `UserDao`를 상속한 서브클래스는 `getConnection()`을 구현한다. 하지만,

- 이 메소드가 어떻게 사용될지 자신은 모른다. (서브클래스에서 결정되는 것이 아니다)
- 단지 기능만 구현해놓으면, 슈퍼클래스인 `UserDao`의 템플릿 메소드(`get()`, `add()`)에서 필요할 떄 호출해서 사용된다.

즉 제어권을 상위 템플릿 메소드로 넘기고, 자신은 필요할 때 호출되어 사용되도록 한다는 제어의 역전 개념을 발견할 수 있다.

> 템플릿 메소드는 제어의 역전이라는 개념을 활용해 문제를 해결하는 디자인 패턴이다.


프레임워크도 제어의 역전 개념이 적용된 대표적인 기술이다.

라이브러리 : 애플리케이션 흐름을 직접 제어하고, 동작하는 중에 필요한 기능이 있을 때 **능동적** 으로 라이브러리를 사용한다.

프레임워크 : 애플리케이션 코드가 프레임워크에 의해 사용된다. 프레임워크가 흐름을 주도하는 중에 개발자가 만든 애플리케이션 코드를 사용하도록 만드는 방식이다. 프레임워크가 짜 놓은 틀에서 **수동적** 으로 동작해야 한다.


`UserDao`와 `DaoFactory`에도 제어의 역전이 적용되어 있다. 자연스럽게 관심을 분리하고 책임을 나누고 유연하게 확장 가능한 구조로 만들기 위해 `DaoFactory`를 도입했던 과정이 바로 IoC를 적용하는 작업이었다고 볼 수 있다.

- `UserDao`는 `ConnectionMaker`의 구현클래스를 결정하고 오브젝트를 만드는 제어권을  `DaoFactory`로 넘김
  - `DaoFactory`가 공급해주는 것을 수동작으로 사용하는 입장이 되었음  
- `UserDaoTest`는 `DaoFactory`를 만들고 초기화해서 자신에게 사용하도록 공급해주는 `ConnectionMaker`를 사용할 수 밖에 없음
- `UserDao`와 `ConnectionMaker`의 구현체를 생성하는 책임도 `DaoFactory`가 맡고 있음


스프링은 대표적인 IoC 프레임워크이지만, 스프링 없이도 해당 개념을 적용해 보았다.
IoC를 적용하면
1. 설계가 깔끔해지고
2. 유연성이 증가하며
3. 확장성이 좋아진다.


제어의 역전에서는 프레임워크 또는 컨테이너 같이 애플리케이션 컴포넌트의 생성과 관계설정, 사용, 생명주기 관리 등을 관장해주는 존재가 필요하다. `DaoFactory`가 가장 단순한 IoC 컨테이너 내지는 IoC 프레임워크 라고 불릴 수 있다.


# 1.5 스프링의 IoC

스프링의 핵심을 담당하는 것은 **빈 팩토리** 또는 **애플리케이션 컨텍스트** 라고 불리는 것이다. 이 두가지는 `DaoFactory`가 하는 일을 좀 더 일반화한 것이라고 설명할 수 있다.

## 1.5.1 오브젝트 팩토리를 이용한 스프링 IoC

### 애플리케이션 컨텍스트와 설정정보

스프링에서는 스프링이 제어권을 가지고 직접 만들고 관계를 부여하는 오브젝트를 **빈(bean)** 이라고 부른다. 스프링 컨테이너가 생성과 관계설정, 사용 등을 제어해주는 제어의 역전이 적용된 오브젝트를 가르키는 말이다.
> 빈(bean) : 오브젝트 단위의 애플리케이션 컴포넌트

이처럼 빈의 생성과 관계설정 같은 **제어** 를 담당하는 **IoC 오브젝트** 를 **빈 팩토리(bean factory)** 라고 부른다.  
**애플리케이션 컨텍스트(Application Context)** 는 IoC 방식을 따라 만들어진 일종의 빈 팩토리로, 보통의 빈 팩토리보다는 좀 더 확장한 것이다.

> 빈 팩토리 : 빈을 생성하고 관계를 설정하는 IoC의 기본 기능에 초점을 맞춘 것
> 애플리케이션 컨텍스트 : 애플리케이션 전반에 걸쳐 모든 구성요소의 제어 작업을 담당하는 IoC 엔진

애플리케이션 컨텍스트(Application Context)는 **별도의 정보를 참고** 해서 빈의 생성, 관계설정 등의 제어 작업을 총괄한다.

설정정보를 만드는 방법은 여러가지가 있는데, `DaoFactory`도 조금만 손을 보면 설정정보로 활용될 수 있다.  
앞에서는 `DaoFactory` 자체가 설정정보까지 담고있는 IoC엔진이었는데,
여기서는 자바 코드로 만든 애플리케이션 컨텍스트의 설정정보로 활용될 것이다.


### DaoFactory를 사용하는 애플리케이션 컨텍스트

`DaoFactory`를 스프링의 빈 팩토리가 사용할 수 있는 본격적인 설정정보로 만들기 위해 다음의 2가지 애노테이션을 추가한다.

**@Configuration** : 빈 팩토리를 위한 오브젝트 설정을 담당하는 클래스라고 인식할 수 있게 함  
**@Bean** : 오브젝트를 만들어줌

애플리케이션 컨텍스트는 `ApplicationContext` 타입의 오브젝트다. `ApplicationContext`를 구현한 클래스는 여러 가지가 있는데,  
`DaoFactory` 처럼 @Configuration이 붙은 자바 코드를 설정정보로 사용하려면 `AnnotationConfigApplicationContext`를 이용하면 된다.   

```java
// 애플리케이션 컨텍스트를 만들 때 생성자 파라미터로 DaoFactory 클래스를 넣어준다.
ApplicationContext context = new AnnotationConfigApplicationContext(DaoFactory.class);
// 준비된 context의 getBean()이라는 메소드를 이용해 UserDao의 오브젝트를 가져올 수 있다.  
UserDao dao = context.getBean("userDao", UserDao.class);  // "userDao" < 빈의 이름
```

`getBean()` 메소드는 `ApplicationContext`가 **관리** 하는 오브젝트를 요청하는 메소드이다.  `DaoFactory`에서 @Bean이라는 애노테이션을 `userDao`라는 메소드에 붙였는데, 이 **메소드 이름** 이 **빈의 이름** 이 된다.

> `userDao`라는 이름의 빈을 가져온다는 것은 `DaoFactory`의 `userDao()` 메소드를 호출해서 그 결과를 가져온다라고 생각하면 된다.


왜 굳이 이름을 사용할까? 그것은 `UserDao`를 생성하는 방식이나 구성을 다르게 가져가는 메소드를 추가할 수 있기 때문이다.
> `getBean("specialUserDao", UserDao.class)` 는 다른 형태로 구성된 `UserDao`를 가져오는 예이다.


## 1.5.2 애플리케이션 컨텍스트의 동작방식


**오브젝트 팩토리** 를 이용했던 방식과 스프링의 **애플리케이션 컨텍스트** 를 사용한 방식을 비교해보자.

**오브젝트 팩토리** 에 대응되는 것이 스프링의 **애플리케이션 컨텍스트** 다.
> **애플리케이션 컨텍스트** 를 *IoC 컨테이너* 라고 하기도 하고 *스프링 컨테이너*, *빈 팩토리* 라고 부르기도 한다.   
> 애플리케이션 컨텍스트는 `ApplicationContext`를 구현하는데, `ApplicationContext`는 빈 팩토리가 구현하는 `BeanFactory` 인터페이스를 상속했으므로 애플리케이션 컨텍스트는 일종의 빈 팩토리인 셈이다.

`DaoFactory`가 DAO 오브젝트를 생성하고 DB 생성 오브젝트와 관계를 맺어주는 제한적인 역할을 하는 데 반해,  
애플리케이션 컨텍스트는 IoC를 적용해서 관리할 **모든 오브젝트에 대한 생성과 관계설정을 담당** 한다.

대신, `ApplicationContext`는 `DaoFactory`와 달리 직접 오브젝트를 생성하고 관계를 맺어주는 코드가 없고, 별도의 설정정보를 통해서 생성정보와 연관관계 정보를 얻는다. 때로는 외부의 오브젝트 팩토리에 그 작업을 위임하고 그 결과를 가져다가 사용하기도 한다.
> xml, `@Configuration ... `

`@Configuration`이 붙은 `DaoFactory`는 이 애플리케이션 컨텍스트가 활용하는 IoC 설정정보다.
애플리케이션 컨텍스트가 `DaoFactory`의 `userDao()` 메소드를 호출해서 오브젝트를 가져온 것을 클라이언트가 `getBean()`으로 요청할 때 전달해준다.


애플리케이션 컨텍스트는  
1. `DaoFactory` 클래스를 설정정보로 등록해두고
2. `@Bean`이 붙은 메소드의 이름을 가져와 빈 목록을 만들어둔다.    

애플리케이션 컨텍스트의 `getBean()` 메소드를 호출하면
1. 애플리케이션 컨텍스트는 자신의 빈 목록에서 요청한 이름이 있는지 찾고,
2. 있다면 빈을 생성하는 메소드를 호출해서 오브젝트를 생성시킨 후 클라이언트에 돌려준다.

복잡해보이지만, 애플리케이션 컨텍스트를 사용하는 이유는 범용적이고 유연한 방법으로 IoC 기능을 확장하기 위해서다.

`DaoFactory`를 오브젝트 팩토리로 직접 사용했을 때와 비교해서 얻을 수 있는 장점은 다음과 같다.

- 클라이언트는 구체적인 팩토리 클래스를 알 필요가 없다
  - `DaoFactory`처럼 IoC를 적용한 오브젝트도 계속 추가될 것인데, 애플리케이션 컨텍스트를 사용하면 오브젝트 팩토리가 아무리 많아져도 어떤 팩토리 클래스를 사용할지 알아야 하거나, 필요할 때마다 팩토리 클래스를 생성해야 하는 번거로움을 느낄 필요가 없다.
- 애플리케이션 컨텍스트는 종합 IoC 서비스를 제공해준다.
  - 애플리케이션 컨텍스트의 역할은 단지 오브젝트의 생성과 다른 오브젝트와의 관계설정 뿐만 아니라 오브젝트가 만들어지는 방식, 시점, 전략을 다르게 가져갈 수 있고 부가적으로 자동생성, 오브젝트 후처리, 정보의 조합, 설정방식의 다변화, 인터셉팅 등 다양한 기능을 제공한다. 또한 빈이 사용할 수 있는 기반기술 서비스나 외부 시스템과의 연동 등을 컨테이너 차원에서 제공해주기도 한다.
- 애플리케이션 컨텍스트는 빈을 검색하는 다양한 방법을 제공한다.
  - `getBean()` 메소드는 빈의 이름을 이용해 빈을 찾아준다. (타입, 애노테이션 설정 등)


## 1.5.3 스프링 IoC의 용어 정리

**빈 Bean**
스프링이 IoC 방식으로 관리하는 오브젝트. 주의) 스프링을 사용하는 애플리케이션에서 만들어지는 모든 오브젝트가 다 빈은 아니다. 스프링이 직접 그 생성과 제어를 담당하는 오브젝트만을 빈이라고 부른다.

**빈 팩토리 Bean factory**
스프링 IoC를 담당하는 핵심 컨테이너.
빈 등록/생성/조회/그 외 부가적인 관리 등의 기능을 담당한다. 보통은 빈 팩토리를 확장한 애플리케이션 컨텍스트를 이용한다.  

**애플리케이션 컨텍스트 ApplicationContext**
빈 팩토리를 확장한 IoC 컨테이너. 빈을 등록하고 관리하는 기본적인 기능에 추가로 스프링이 제공하는 각종 부가 서비스를 추가로 제공한다. `ApplicationContext`는 `BeanFactory`를 상속한다.

```java
package org.springframework.context;

public interface ApplicationContext extends EnvironmentCapable, ListableBeanFactory, HierarchicalBeanFactory,
		MessageSource, ApplicationEventPublisher, ResourcePatternResolver {

```

**설정정보/설정 메타정보 Confiruation Metadata**
빈 팩토리가 IoC를 적용하기 위해 사용하는 메타정보를 말한다. 컨테이너의 어떤 기능을 세팅하거나 조정하는 경우에도 사용하지만, 그보다는 IoC 컨테이너에 의해 관리되는 애플리케이션 오브젝트를 생성하고 구성할 때 사용된다. 애플리케이션 형상정보라고 부르기도 한다.

**컨테이너 또는 IoC 컨테이너**
IoC 방식으로 빈을 관리한다는 의미에서 애플리케이션 컨텍스트나 빈 팩토리를 컨테이너(*애플리케이션 컨텍스트를 가르킬 때*, *스프링 컨테이너*, *스프링* 이라고도 함) 또는 IoC 컨테이너(*빈 백토리의 관점*)라고도 한다.
애플리케이션 컨텍스트 오브젝트(`ApplicationContext`를 구현한 오브젝트)는 하나의 애플리케이션에서 보통 여러 개가 만들어져 사용되는데, 이를 통틀어서 스프링 컨테이너라고 부를 수 있다.

**스프링 프레임워크**
IoC 컨테이너, 애플리케이션 컨텍스트를 포함해서 스프링이 제공하는 모든 기능을 통틀어 말할 때 주로 사용된다.





# 1.6 싱글톤 레지스트리와 오브젝트 스코프

스프링의 애플리케이션 컨텍스트는 기존에 직접 만들었던 오브젝트 팩토리와는 중요한 차이점이 있다.  
`DaoFactory`의 `userDao()` 메소드를 두 번 호출해서 리턴되는 `UserDao` 오브젝트는 두 개를 같은 오브젝트일까?

```java
DaoFacotry factory = new DaoFactory();
UserDao dao1 = facotry.userDao();
UserDao dao2 = facotry.userDao();

System.out.println(dao1);
System.out.println(dao2);
```

```java
AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(DaoFacotry.class);

UserDao dao3 = context.getBean("userDao", UserDao.class);
UserDao dao4 = context.getBean("userDao", UserDao.class);

System.out.println(dao3);
System.out.println(dao4);
```


직접 생성한 `DaoFactory`에서는 매번 다른 오브젝트가 리턴되지만, 애플리케이션 컨텍스트에 `DaoFactory`를 설정 정보로 등록하고 `getBean()` 메소드를 이용해 등록된 오브젝트를 가져올 경우, 여러 번 오브젝트를 가져오더라도 리턴된 오브젝트들은 동일하다는 것을 알 수 있다. 즉, 스프링은 여러 번에 걸쳐 빈을 요청하더라도 매번 동일한 오브젝트를 돌려준다는 것이다.

왜 그럴까?

## 1.6.1 싱글톤 레지스트리로서의 애플리케이션 컨텍스트

애플리케이션 컨텍스트는 오브젝트 팩토리와 비슷한 방식으로 동작하는 IoC 컨테이너다. 그러면서 동시에 싱글톤을 저장하고 관리하는 **싱글톤 레지스트리(Singleton Registry)** 이기도 하다.

스프링은 내부에서 생성하는 빈 오브젝트를 모두 싱글톤으로 만든다. 디자인 패턴의 싱글톤 패턴과 비슷한 개념이지만, 구현 방법은 확연히 다르다.

### 서버 애플리케이션과 싱글톤

왜 스프링은 싱글톤으로 빈을 만드는 것일까?  
이는 스프링의 주 적용 대상이 서버환경이기 때문이다. 태생적으로 엔터프라이즈 시스템을 위해 고안된 기술이기 때문에 서버 환경에서 사용될 때 그 가치가 있다.

그런데 매번 클라이언트에서 요청이 올 때마다 로직을 담당하는 오브젝트를 새로 만들어서 사용한다고 하면, 자바의 오브젝트 생성과 GC의 성능이 좋아졌다고 한들 서버의 부하를 감당하기 힘들다.

그래서 서버환경에서는 애플리케이션 안에 제한된 수, 대개 한 개의 오브젝트만 만들어서 사용하는 것이 권장된다. 하지만 디자인 패턴에 소개된 싱글톤 패턴은 여러 문제점이 있다.

### 싱글톤 패턴의 한계

싱글톤을 구현하는 방법은 보통 이렇다.
- 생성자는 private으로 선언하여 클래스 밖에서의 오브젝트 생성을 막는다
- 생성된 싱글톤 오브젝트를 저장할 수 있는 스태틱 필드를 정의한다.
- 스태틱 팩토리 메소드인 `getInstance()`를 만들고 메소드가 최초로 호출되는 시점에서 한번만 오브젝트가 만들어지게 한다. 생성된 오브젝트는 스태틱 필드에 저장된다. 또는 초기값으로 오브젝트를 미리 만들어둘 수도 있다.
- 한번 오브젝트가 만들어지고 난 후에는 `getInstance()` 메소드를 통해 이미 만들어져 스태틱 필드에 저장해둔 오브젝트를 넘겨준다.

일반적으로 싱글톤 패턴 구현 방식에는 다음과 같은 문제가 있다.

**private 생성자를 갖고 있기 때문에 상속할 수 없다.**
싱글톤 패턴은 생성자를 private으로 제한한다. 문제는 private 생성자를 가진 클래스는 다른 생성자가 없다면 상속이 불가능하다는 점이다. 객체지향의 장점인 상속과 이를 이용한 다형성을 적용할 수 없다. 애플리케이션의 로직을 담고 있는 일반 오브젝트가 객체지향적인 설계의 장점을 적용하기 어렵다는 점은 심각한 문제이다.

**싱글톤은 테스트하기가 힘들다**
싱글톤은 테스트하기가 어렵거나 테스트 방법에 따라 아예 테스트가 불가능하다. 초기화 과정에서 생성자 등을 통해 사용할 오브젝트를 다이내믹하게 주입하기도 힘들기 때문에 필요한 오브젝트는 직접 오브젝트를 만들어 사용할 수 밖에 없다. 이런 경우 테스트용 오브젝트로 대체하기가 힘들다.

**서버환경에서는 싱글톤이 하나만 만들어지는 것을 보장하지 못한다**
서버에서 클래스 로더를 어떻게 구성하고 있느냐에 따라 싱글톤 클래스임에도 하나 이상의 오브젝트가 만들어질 수 있다.

> Singletons are also bad when it comes to clustering. Because then, you do not have "exactly one singleton" in your application anymore. https://stackoverflow.com/a/15026525


**싱글톤의 사용은 전역 상태를 만들 수 있기 때문에 바람직하지 못하다.**
싱글톤의 스태틱 메소드를 이용해 언제든지 싱글톤 오브젝트에 쉽게 접근할 수 있기 때문에 애플리케이션 어디서든지 사용될 수 있고, 그러다 보면 자연스럽게 전역 상태로 사용되기 쉽다. 아무 객체나 자유롭게 접근하고 수정하고 공유할 수 있는 전역 상태를 갖는 것은 객체지향 프로그래밍에서는 권장되지 않는 프로그래밍 모델이다.


### 싱글톤 레지스트리

자바의 기본적인 싱글톤 패턴의 구현 방식이 여러 가지 단점이 있기 때문에, 스프링은 직접 싱글톤 형태의 오브젝트를 만들고 관리하는 기능, **싱글톤 레지스트리** 를 제공한다.
스프링 컨테이너는 싱글톤을 생성하고, 관리하고, 공급하는 싱글톤 관리 컨테이너이기도 하다.

싱글톤 레지스트리 덕분에 평범한 자바 클래스를 싱글톤으로 활용할 수 있게 되고, 싱글톤 방식으로 사용될 클래스라도 public 생성자를 가질 수 있다. 그래서 테스트 환경에서 자유롭게 오브젝트를 만들 수 있게 된다. 또한 객체지향적인 설계 방식과 원칙, 디자인 패턴 등을 적용하는 데 아무런 제약이 없다.

스프링이 빈을 싱글톤으로 만드는 것은 결국 오브젝트의 생성 방법을 제어하는 IoC 컨테이너로서의 역할이다.

## 1.6.2 싱글톤과 오브젝트의 상태

싱글톤은 여러 스레드가 동시에 접근해서 사용할 수 있기 때문에 상태 관리에 주의해야한다.
싱글톤이 멀티스레드 환경에서 서비스 형태의 오브젝트로 사용되는 경우에는 상태정보를 내부에 갖고 있지 않은 무방식(stateless) 방식으로 만들어져야 한다. 즉, 다중 사용자의 요청을 한꺼번에 처리하는 스레드들이 동시에 싱글톤 오브젝트의 인스턴스 변수를 수정하는 것은 매우 위험하다. 저장할 공간이 하나뿐이니 서로 값을 덮어쓰고 자신이 저장하지 않은 값을 읽어올 수 있기 때문이다.

상태가 없는 방식으로 클래스를 만드는 경우에는 파라미터와 로컬 변수, 리턴 값등을 이용한다.
또한 자신이 사용하는 다른 싱글톤 빈을 저장하려는 용도라면 인스턴스 변수를 사용해도 좋다.
동일하게 읽기전용의 속성을 가진 정보라면 싱글톤에서 인스턴스 변수로 사용해도 좋지만, 단순 읽기전용 값이라면 `static final`이나 `final`로 선언하는 편이 낫다.


## 1.6.3 스프링 빈의 스코프

스프링이 관리하는 오브젝트가 생성되고, 존재하고, 적용되는 범위를 빈의 **스코프** 라고 한다. 기본 스코프는 싱글톤이며, 컨테이너 내에 한 개만 만들어져서 강제로 제거하지 않는 한 스프링 컨테이너가 존재하는 동안 계속 유지된다. 대부분의 빈은 싱글톤 스코프를 갖는다.

그 외에 프로토타입(prototype), 요청(request), 세션(session) 스코프도 있다. 10장에서 계속..

# 1.7 의존관계 주입

## 1.7.1 제어의 역전(IoC)과 의존관계 주입

`DaoFacotry`처럼 객체를 생성하고 관계를 맺어주는 등의 작업을 담당하는 기능을 일반화한 것이 스프링의 IoC 컨테이너다.   

하지만 IoC 컨테이너라는 용어는 스프링이 제공하는 기능의 특징을 명확하게 설명하지 못한다. 그래서 의존관계 주입(Dependency Injection)이라는 이름으로 스프링이 제공하는 IoC 방식을 좀 더 의도가 명확히 드러나도록 명하고 있다. 물론 기본 동작 원리가 모두 IoC 방식 이지만, 다른 프레임워크와 차별화돼서 제공해주는 기능은 의존관계 주입이라는 용어를 사용할 때 분명하게 드러난다.


## 1.7.2 런타임 의존관계 설정

### 의존관계

의존한다는 것은 의존 대상이 변하면 의존하고 있는 것이 영향을 미친다는 것이다.
> A- > B 의 방향으로 의존한다라고 하면, B가 의존 대상. B가 변하면 A가 영향을 받는다.
A는 B에 의존하고 있지만, B는 A에 의존하지 않는다.

### UserDao의 의존관계

`UserDao`는 `ConnectionMaker` 인터페이스에 의존하고 있다. 하지만 `ConnectionMaker` 인터페이스를 구현한 클래스가 다른 것으로 바뀌거나, 그 내부에서 사용하는 메소드에 변화가 생겨도 `UserDao`에 영향을 주지 않는다.  
즉 **인터페이스** 에 대해서만 의존관계를 만들어두면 인터페이스 **구현 클래스** 와의 관계는 느슨해지면서 변화에 영향을 덜 받는 상태가 된다.
> 변화에 영향을 덜 받는다 = *결합도*가 낮다

모델이나 코드에서 클래스와 인터페이스를 통해 드러나는 의존관계 말고, **런타임** 시에 오브젝트 사이에서 만들어지는 의존관계도 있다. 런타임 의존관계(혹은 오브젝트 의존관계)인데, 설계 시점의 의존관계가 실체화된 것이라고 볼 수 있다.

설계 시점에 느슨한 의존관계를 갖는 경우에는 오브젝트가 런타임 시 어떤 인터페이스의 구현체를 사용할 지 미리 알 수가 없다. 프로그램이 시작되고, 오브젝트가 만들어지고 나서 런타임 시에 의존 관계를 맺는 대상 오브젝트를 **의존 오브젝트** 라고 한다.

**의존관계 주입** 은 구체적인 의존 오브젝트와 그것을 사용할 주체를 런타임 시에 연결해주는 작업을 말한다.

- 클래스 모델이나 코드에는 런타임 시점의 의존관계가 드러나지 않고, 인터페이스에만 의존하고 있어야 한다.
- 런타임 시점의 의존관계는 컨테이너나 팩토리 같은 제3의 존재가 결정한다.
- 의존관계는 사용할 오브젝트에 대한 레퍼런스를 외부에서 제공(주입)해줌으로써 만들어진다.

핵심은 두 오브젝트의 관계를 맺도록 도와주는 제3의 존재가 있다는 것이다. DI에서 말하는 제3의 존재는 관계설정 책임을 가진 코드를 분리해서 만들어진 오브젝트, `DaoFacotry`, 애플리케이션 컨텍스트, 빈 팩토리, IoC 컨테이너 등이 될 수 있다.

### UserDao의 의존관계 주입

관계설정 책임을 분리하기 전의 `UserDao`는 이미 런타임 시의 의존관계가 코드 속에 다 미리 결정되어 있는 문제를 가지고 있었다.
```java
public UserDao(){
  connectionMaker = new DConnectionMaker();
}
```

그래서 IoC 방식을 써서 제3의 존재에 런타임 의존관계 결정 권한을 위임했다.
`DaoFacotry`(*제3의 존재가 결정*)는 런타임 시점에 `UserDao`가 사용할 `ConnectionMaker` 타입의 오브젝트를 결정(*인터페이스에만 의존*)하고 이를 생성한 후 `UserDao`의 생성자 파라미터로 주입(*레퍼런스를 외부에서 제공*)해서 `UserDao`와 `DConnectionMaker`의 오브젝트와 런타임 의존관계를 맺게 해준다.



`DaoFacotry`는
- 의존관계 주입 작업을 주도하는 존재이며 -> *DI*
   > DI 조건 : 인터페이스에만 의존관계 형성, 의존관계는 제3의 존재가 결정, 의존 오브젝트는 외부에서 주입   
- 오브젝트의 생성과 초기화, 제공 등의 작업을 수행하는 컨테이너다. -> *IoC*의 개념이 적용됨
  > IoC : 제어권을 다른 존재에게 넘기고, 자신은 필요할 때 호출되어 사용되도록 한다

따라서 DI 컨테이너라고 불리기도 한다. (IoC/DI 컨테이너라고 불리기도 한다.)


DI 컨테이너에 의해 런타임 시에 의존 오브젝트를 사용할 수 있도록 그 레퍼런스를 전달받는 과정이 마치 생성자를 통해 DI 컨테이너가 `UserDao`에게 주입해주는 것과 같다고 해서 이를 의존관계 주입이라고 부른다.

**DI** 는 *자신이 사용할 오브젝트에 대한 선택과 생성 제어권을 외부에 넘기고, 자신은 수동적으로 주입받은 오브젝트를 사용한다는 점에서* **IoC** 의 개념에 잘 들어 맞는다.

스프링 컨테이너의 IoC는 주로 DI에 초점이 맞춰져있다. 그래서 IoC 컨테이너 외에도 DI 컨테이너 또는 DI 프레임워크라고 부르는 것이다.


## 1.7.3 의존관계 검색과 주입

스프링이 제공하는 IoC 방법에는 의존관계 주입(DI)뿐만 아니라 의존관계를 외부로부터의 주입이 아니라 스스로 검색을 이용하는 **의존관계 검색(Dependency Lookup)** 이라고 불리는 것도 있다.

**의존관계 검색** 은 자신이 필요로 하는 의존 오브젝트를 능동적으로 찾는다. 물론 자신이 어떤 클래스의 오브젝트를 이용할지를 결정하진 않는다. 런타임 시 의존관계를 맺을 오브젝트를 결정하는 것과 오브젝트의 생성 작업은 외부 컨테이너에게 맡기지만(IoC), *이를 가져올 때는* *메소드나 생성자를 통한 주입* 대신 **스스로 컨테이너에게 요청하는 방법** 을 사용한다.


```java
public UserDao(){
    DaoFactory factory = new DaoFacotry();
    this.connectionMaker = DaoFacotry.connectionMaker();
}
```

이렇게 해도 여전히 의존대상은 `ConnectionMaker`이고, 런타임 시 `DaoFacotry`가 만들어서 만들어서 돌려주는 오브젝트와 다이내믹하게 런타임 의존관계를 맺는다. 하지만 적용 방법은 외부로부터의 주입이 아니라 스스로 IoC 컨테이너인 `DaoFacotry`에게 요청하는 것이다.

이런 작업을 일반화한 스프링의 애플리케이션 컨텍스트는 미리 정해놓은 이름을 전달해서 그 이름에 해당하는 오브젝트를 찾는다. 이를 일종의 **검색** 이라고 볼 수 있다.

스프링의 IoC 컨테이너인 애플리케이션 컨텍스트는 아래와 같이 `getBean()`이라는 메소드를 제공하여 의존관계 검색을 제공한다.

```java
public UserDao() {

  AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(DaoFacotry.class);
  this.connectionMaker = context.getBean("connectionMaker", ConnectionMaker.class);
}

```

의존관계 **검색** 과 의존관계 **주입** 중 어떤 것이 더 나을까?
*의존관계 주입 쪽이 훨씬 단순하고 깔끔하다.*  
왜냐하면 의존관계 검색은 코드 안에 오브젝트 팩토리 클래스나 스프링 API가 나타나게 된다. 성격이 다른 오브젝트에 의존하게 되는 것이므로 바람직하지 않다.

그런데 의존관계 검색 방식을 사용해야 할 때가 있다.  

스프링과의 IoC와 DI 컨테이너를 적용했다고 하더라도 애플리케이션의 기동 시점에서 적어도 한 번은 의존관계 검색 방식을 사용해 오브젝트를 가져와야 한다. 왜냐하면 스태틱 메소드인 main()에서는 DI를 이용해 오브젝트를 주입받을 방법이 없기 때문이다.   

서버에는 `main()`과 같은 기동 메소드는 없지만, 서블릿에서 스프링 컨테이너에 담긴 오브젝트를 사용하려면 한 번은 의존관계 검색 방식을 사용해 오브젝트를 가져와야 한다.
> 스프링은 미리 만들어서 제공하기 때문에 구현할 필요는 없다.


**의존관계 검색**은 검색하는 오브젝트는 자신이 스프링의 빈일 필요가 없다.  

반면에 **의존관계 주입** 은 반드시 주입 대상과 주입하는 주체 모두 컨테이너가 만드는 빈 오브젝트여야 한다.  
컨테이너가 `UserDao`에 `ConnectionMaker` 오브젝트를 주입해주려면 `UserDao`에 대한 생성과 초기화 권한을 가지고 있어야 하고, 그러려면 `UserDao`는 IoC 방식으로 컨테이너에서 생성되는 오브젝트, 즉 빈이어야 하기 때문이다.


DI는 원하는 오브젝트는 먼저 자기 자신이 컨테이너가 관리하는 빈이 돼야 한다.


## 1.7.4 의존관계 주입의 응용

런타임 시에 사용 의존관계를 맺을 오브젝트를 주입해준다는 DI 기술의 장점은 무엇일까?

다른 책임을 가진 사용 의존놘계에 있는 대상이 바뀌거나 변경되더라도 자신은 영향을 받지 않으며, 변경을 통한 다양한 확장 방법에는 자유롭다.

### 기능 구현의 교환

개발, 운영 환경에 따라 DB 커넥션 정보를 달리하고 싶을 때,
개발환경과 운영환경에서 DI의 설정정보에 해당하는 `DaoFacotry`만 다르게 만들어두면 **나머지 코드에는 전혀 손대지 않고** 개발 시와 운영 시에 각각 다른 런타임 오브젝트에 의존관계를 갖게 해줘서 문제를 해결할 수 있다.


### 부가기능 추가

DAO가 DB를 얼마나 많이 연결해서 사용하는지 파악하고 싶은 니즈가 있거나 그 외 부가기능을 추가할 때도 DI의 개념만 이용하면 기존 코드의 수정 없이 컨테이너가 사용하는 설정정보만 수정해서 런타임 의존관계만 새롭게 정의해주면 된다.



## 1.7.5 메소드를 이용한 의존관계 주입

지금까지는 의존관계 주입을 위해 생성자를 사용했는데, 다른 방법은 없을까?

**수정자 메소드를 이용한 주입** 수정자 메소드(*setter*)의 핵심 기능은 파라미터로 전달된 값을 보통 내부의 인스턴스 변수에 저장하는 것이다. 외부로부터 제공받은 오브젝트 레퍼런스를 저장해뒀다가 내부의 메소드에서 사용하게 하는 DI방식에서 활용하기에 적당하다.

**일반 메소드를 이용한 주입** 수정자 메소드처럼 set으로 시작해야 하고, 한 번에 한 개의 파라미터만 가질 수 있다는 제약이 싫다면 여러 개의 파라미터를 갖는 일반 메소드를 DI용으로 사용할 수도 있다. 장점은 한 번에 여러 개의 파라미터를 받을 수 있는 것이지만, 이는 파라미터가 많아지고 비슷한 타입이 여러 개 생길 수록 실수하기 쉽다. 적절한 개수의 파라미터를 가진 여러 개의 초기화 메소드를 만들 수 있기 때문에 한번에 모든 필요한 파라미터를 다 받아야 하는 생성자보다 낫다.

전통적으로 XML을 사용하는 경우에는 자바빈 규약을 따르는 수정자 메소드가 가장 사용하기 편리하고, 전통적으로 가장 많이 사용해왔다. 수정자 메소드의 이름은 오브젝트 타입의 이름을 따는 것이 가장 무난하다.

이 외에도 다양한 방법의 의존관계 주입 방법을 지원한다. 자세한 내용은 Vol.2에서 계속..


# 1.8 XML을 이용한 설정

스프링은 `DaoFacotry`와 같은 자바클래스를 이용하는 것 외에도, 다양한 방법을 통해 DI 의존관계 설정정보를 만들 수 있다. 가장 대표적인 것이 XML이다.

> 하지만 XML은 자바 코드처럼 유연하게 정의될 수 없다.

XML은
- 텍스트 파일이기 때문에 다루기 쉽고
- 쉽게 이해할 수 있으며
- 컴파일과 같은 별도의 빌드 작업이 없다.

## 1.8.1 XML 설정

XML 설정은 `@Confiruation`과 `@Bean`이 붙은 자바 클래스로 만든 설정과 내용이 동일하다.
`@Confiruation`을 `<beans>`, `@Bean`을 `<bean>`에 대응해서 생각하면 이해하기 쉬울 것이다.  

하나의 `@Bean` 메소드를 통해 얻을 수 있는 빈의 DI 정보는 다음 세가지다. `<bean>`을 사용해도 이 세가지 정보를 정의할 수 있다.

- 빈의 이름 : `getBean()`에서 사용되는 `@Bean` 메소드 이름
- 빈의 클래스 : 어떤 클래스를 이용해서 만들지를 정의
- 빈의 의존 오브젝트 : 빈의 생성자나 수정자 메소드를 통해 의존 오브젝트를 넣어준다. (생략 가능)

### connectionMaker()의 전환

```XML

<!--빈의 설정파일 : beans-->
<beans>
    <!--메소드 이름(빈의 이름):id-->
    <!--클래스 이름(빈의 클래스):class-->
    <bean id="userDao" class="springbook.user.domain.UserDao">
        <!--프로퍼티의 이름(수정자 메소드의 프로퍼티 이름):name-->
        <!--오브젝트의 빈 이름(주입할 오브젝트를 정의한 빈):ref-->
        <property name="connectionMaker" ref="connectionMaker" />
    </bean>

    <bean id="connectionMaker" class="springbook.user.domain.DConnectionMaker"/>
</beans>
```

같은 인터페이스를 구현한 의존 오브젝트를 여러 개 정의해두고 그중에서 원하는 걸 골라서 DI 하는 경우도 있다. 이 때는 각 빈의 이름을 독립적으로 만들어두고 ref 애트리뷰트를 이용해 DI 받을 빈을 지정해주면 된다.

## 1.8.2 XML을 이용하는 애플리케이션 컨텍스트

애플리케이션 컨텍스트가 `DaoFacotry` 대신 XML에 작성한 설정정보를 활용하도록 만들어보자.
`UserDaoTest`의 애플리케이션 컨텍스트 생성 부분을 `AnnotationConfigApplicationContext` 대신 `GenericXmlApplicationContext`를 이용해 애플리케이션 컨텍스트를 생성하게 만든다.

`GenericXmlApplicationContext` 외에도 `ClassPathXmlApplicationContext`를 이용해 애플리케이션 컨텍스트를 만들 수 있다.

`GenericXmlApplicationContext` 는 클래스패스뿐 아니라 다양한 소스로부터 설정파일을 읽어올 수 있다.  
`ClassPathXmlApplicationContext` 는 XML 파일을 클래스패스에서 가져올 때 사용할 수 있는 편리한 기능이 추가된 것이다.

예를 들어 전자는 특정 패키지 하의 설정 파일을 가져오려면 클래스패스 루트로부터 파일의 위치를 모두 지정해야 하는데, 후자는 XML 파일과 같은 클래스패스에 있는 클래스 오브젝트를 넘겨서 클래스패스에 대한 힌트를 제공할 수 있다.

```java
// GenericXmlApplicationContext을 이용한 ApplicationContext
ApplicationContext context1 = new GenericXmlApplicationContext("springbook/user/dao/daoContext.xml");

// ClassPathXmlApplicationContext을 이용한 ApplicationContext
ApplicationContext context2 = new ClassPathXmlApplicationContext("daoContext.xml", UseDao.class);

```


## 1.8.3 DataSource 인터페이스로 변환

### DataSource 인터페이스 적용

`ConnectionMaker`는 DB 커넥션을 생성해주는 기능 하나만을 정의한 매우 단순한 인터페이스다. 자바에서는 DB 커넥션을 가져오는 오브젝트의 기능을 추상화해서 비슷한 용도로 사용할 수 있게 만들어진 `DataSource`라는 인터페이스가 이미 존재한다.

일반적으로 `DataSource`를 구현해서 DB 커넥션을 구현해서 DB 커넥션을 제공하는 클래스를 만들 일은 거의 없다. 이미 다양한 구현 클래스가 존재하고, 가져다 사용하면 충분하다. 대부분의 `DataSource` 구현 클래스는 DB의 종류나 아이디, 비밀번호 정도는 구현 클래스를 다시 만들지 않고도 지정할 수 있는 방법을 제공한다.

`DataSource` 인터페이스와 다양한 `DataSource` 구현 클래스를 사용할 수 있도록  `UserDao`를 자바 코드 설정 방식과 XML 방식으로 리팩토링해보자.

그런데 XML 방식을 적용할 때, 어떻게 하면 DB 연결정보를 넣도록 설정을 만들 수 있을까?


## 1.8.4 프로퍼티 값의 주입

### 값 주입

다른 빈 오브젝트의 레퍼런스가 아닌 단순 텍스트 정보도 오브젝트를 초기화하는 과정에서 수정자 메소드에 넣을 수 있다.  
이때는 DI처럼 오브젝트의 구현 클래스를 다이내믹하게 바꿀 수 있게 해주는 것 대신, 클래스 외부에서 DB 연결정보와 같이 변경 가능한 정보를 설정해줄 수 있도록 만들기 위한 목적이다.  
> 예) DB 접속 아이디가 바뀌었더라도 클래스 코드는 수정해줄 필요가 없게 해준다.

텍스트나 단순 오브젝트 등을 수정자 메소드에 넣어주는 것을 스프링에서는 '값을 주입한다'고 말한다.  
일종의 DI라고 볼 수 있는데, 사용할 오브젝트 자체를 바꾸지는 않지만 오브젝트의 특성은 외부에서 변경할 수 있기 때문이다.

```xml
<bean id="dataSource" class="org.springframework.jdbc.datasource.SimpleDriverDataSource">
    <property name="driverClass" value="com.mysql.cj.jdbc.Driver"/>
    <property name="url" value="jdbc:mysql://localhost/springbook"/>
    <property name="username" value="spring"/>
    <property name="password" value="sss123"/>
</bean>

```

### value 값의 자동 변환
그런데 `driverClass`는 스트링 타입이 아니라 `java.lang.Class` 타입이다. XML에서는 별다른 타입정보 없이 클래스 이름이 텍스트 형태로 value에 들어가 있다. 어떻게 아무런 문제 없이 동작할까?

이유는 스프링이 프로퍼티 값을, 수정자 메소드의 파라미터 타입을 참고해서 적절한 형태로 변환해주기 때문이다. 내부적으로 다음과 같은 변환 작업이 일어난다고 생각하면 된다. Vol.2에서 좀 더 자세히 다룰 것이다.

```java
Class driverClass = Class.forName("com.mysql.jdbc.Driver");
dataSource.setDriverClass(driverClass);
```


# 1.9 정리

스프링이란 '어떻게 오브젝트가 설계되고, 만들어지고, 어떻게 관계를 맺고 사용되는지 관심을 갖는 프레임워크' 이다.  
오직 *오브젝트* 와 그 *관계* 에 관심이 있다.   
이를 어떻게 설계, 분리, 개선, 관계부여 를 결정하는 일은 전적으로 개발자의 역할이며 책임이다.




# 참고
- mysql timezone 설정
https://jwkim96.tistory.com/23
- mysql connector
https://dev.mysql.com/downloads/connector/j/
- mysql 계정 설정
https://linuxize.com/post/how-to-change-mysql-user-password/
