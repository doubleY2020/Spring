5장에서는 지금까지 만든 DAO에 트랜잭션을 적용해보면서 스프링이 어떻게 성격이 비슷한 여러 종류의 기술을 추상화하고 이를 일관된 방법으로 사용할 수 있도록 지원하는지를 살펴볼 것이다.


# 5.1 사용자 레벨 관리 기능 추가

지금까지 만들었던 `UserDao`에 사용자의 활동내역을 참고해서 레벨을 조정해주는 기능을 넣어보자.

사용자 관리 기능에서 구현해야 할 비즈니스 로직은 다음과 같다.

- 사용자의 레벨은 BASIC, SILVER, GOLD 세 가지 중 하나다.
- 사용자가 처음 가입하면 BASIC 레벨이 되며, 이후 활동에 따라서 한 단계씩 업그레이드될 수 있다.
- 가입 후 50회 이상 로그인을 하면 BASIC에서 SILVER 레벨이 된다.
- SILVER 레벨이면서 30번 이상 추천을 받으면 GOLD 레벨이 된다.
- 사용자 레벨의 변경 작업은 일정한 주기를 가지고 일괄적으로 진행된다. 변경 작업 전에는 조건을 충족하더라도 레벨의 변경이 일어나지 않는다.


## 5.1.1 필드 추가

### Level enum
`User` 클래스에 사용자의 레벨을 저장할 필드를 추가하자.

- DB 에는 각 레벨을 코드화해서 숫자로 넣는다. DB 용량도 많이 차지하지 않고 가볍다.
- 자바의 `User`에는 숫자 타입을 직접 사용하는 것보다 enum을 이용하는 것이 안전하고 편리하다.
  - 숫자로 상수로 정의해 놓고 사용하면, 다른 종류의 정보를 넣는 실수를 해도 컴파일러가 체크해주지 못한다.

`Level` enum은 내부에는 DB에 저장할 int 타입의 값을 갖고 있지만, 겉으로는 `Level` 타입의 오브젝트이기 때문에 안전하게 사용할 수 있다.  

### User 필드 추가
`Level` 타입의 변수를 `User` 클래스, user DB에 추가하자.



### UserDaoTest 테스트 수정
`UserDaoJdbc`와 테스트에도 필드를 추가해야 한다. 테스트까지 갖추고 있는 안정된 코드이기 때문에, 기존 코드에 새로운 기능을 추가하려면 테스트를 먼저 만드는 것이 안전하다.


### JdbcDaoJdbc 수정
미리 준비된 테스트가 성공하도록 `UserDaoJdbc` 클래스를 수정한다.  




## 5.1.2 사용자 수정 기능 추가
수정할 정보가 담긴 `User` 오브젝트를 전달하면 id를 참고해서 사용자를 찾아 필드 정보를 UPDATE 문을 이용해 모두 변경해주는 메소드를 하나 만들자.

### 수정 기능 테스트 추가

픽스쳐 오브젝트를 하나 등록하고, id를 제외한 필드의 내용을 바꾼 뒤 `update()`를 호출한다.  
이제 다시 id로 조회해서 가져온 `User` 오브젝트와 수정한 픽스처 오브젝트를 비교하여 해당 id의 사용자 정보가 변경됐음을 확인하자.  

### UserDao와 UserDaoJdbc 수정
`UserDao` 인터페이스에 `update()` 메소드를 추가한다.


### 수정 테스트 보완
JDBC 개발에서 리소스 반환과 같은 기본 작업을 제외하면 가장 많은 실수가 일어나는 곳은 SQL 문장이다.

테스트로는 검증하지 못하는 오류가 있을 수 있는데, UPDATE 문장에서 WHERE 절을 빼먹는 경우이다.
update() 테스트에서 바뀐 로우의 내용만 확인해보면 정상적으로 동작한 것으로 보이지만,  
수정하지 않아야 할 로우의 내용이 그대로 남아 있는지 확인이 필요하다.

이 문제를 해결하려면 다음과 같은 방법이 있을 수 있다.

1. `JdbcTemplate`의 `update()`가 돌려주는 리턴 값을 확인한다.   
`JdbcTemplate`의 `update()`는 UPDATE나 DELETE 같이 테이블의 내용에 영향을 주는 SQL을 실행하면 영향받은 로우의 개수를 돌려주는데, `update()` 테스트라면 이 값이 1인지 확인하는 코드를 하나 더 추가해주면 된다.

2. 테스트를 보강해서 원하는 사용자 외의 정보는 변경되지 않았음을 직접 확인한다.  
사용자를 두 명 등록해놓고, 그중 하나만 수정한 뒤에 수정된 사용자와 수정하지 않은 사용자의 정보를 모두 확인하면 된다.

두번째를 적용하여, `update()` 메소드의 SQL에서 WHERE를 제외하고 테스트가 실패하는지도 함께 확인해보자.


## 5.1.3 UserService.upgradeLevels()

사용자 관리 로직은 어디다 두는 것이 좋을까? `UserDaoJdbc`는 데이터를 어떻게 가져오고 조작할지를 다루는 곳이지 비즈니스 로직을 두는 곳이 아니다.  

사용자 관리 비즈니스 로직을 담을 `UserService` 클래스를 추가하자.
`UserDao`의 구현 클래스가 바뀌어도 영향받지 않도록 해야 하므로, DAO의 인터페이스를 사용하고 DI를 적용한다.  DI를 적용하려면 당연히 `UserService`도 스프링 빈으로 등록돼야 한다.



### UserService 클래스와 빈 등록
`UserSer'` 클래스를 만들고 사용할 `UserDao` 오브젝트를 저장해둘 인스턴스 변수를 선언한다. 그리고 스프링 설정파일에 `userService` 아이디로 빈을 추가한다.

### UserServiceTest 테스트 클래스

`UserServiceTest` 클래스를 추가하고 테스트 대상인 `UserService` 빈을 제공받을 수 있도록 `@Autowired`가 붙은 인스턴스 변수로 선언해준다.

### upgradeLevels() 메소드
사용자 레벨 관리 기능을 먼저 만들고 테스트를 만들어보자.

### upgradeLevels() 테스트

테스트 방법은, 적어도 가능한 모든 조건을 하나씩은 확인해봐야 한다. 사용자 레벨은 BASIC, SILVER, GOLD 세 가지가 있고, 변경이 일어나지 않는 GOLD를 제외한 나머지는 두 가지 업그레이드가 되는 경우와 아닌 경우가 있을 수 있으므로 쵷소한 다섯 가지 경우를 살펴봐야 한다.  

다섯 종류의 사용자 정보를 등록해두고 업그레이드를 진행한 후에 예상한 대로 결과가 나오는지 확인해보자.


## 5.1.4 UserService.add()

요구사항 중 사용자 관리 비즈니스 로직에서 대부분은 구현했지만, 처음 가입하는 사용자의 레벨을 지정하는 부분이 남았다. 이 로직은 어디에 담는 것이 좋을까?

**`UserDaoJdbc`의 `add()` 메소드** : 적합하지 않다. `User` 오브젝트를 DB에 정보를 넣고 읽는 방법에만 관심을 가져야지, 비즈니스적인 의미를 지닌 정보를 설정하는 책임을 지는 것은 바람직하지 않다.   

**User클래스 level 필드를 Level.BASIC으로 초기화** : 처음 가입할 때를 제외하면 무의미한 정보이므로, 이 로직을 담기 위해 클래스에서 직접 초기화하는 것은 문제가 있다.


**UserService의 add() 메소드** : 사용자 정보를 담은 `User` 오브젝트를 받아서 DB에 넣어주는 데 충실한 역할을 한다면, `UserService`에도 `add()`를 만들어두고 사용자가 등록될 때 적용할 만한 비즈니스 로직을 담당하게 만든다.   단, level이 미리 설정되어 있을 수 있으므로, 설정된 경우와 설정되지 않은 경우 2 가지의 케이스를 분리하여 대응하도록 한다.



## 5.1.5 코드 개선

비즈니스 로직의 구현을 모두 마쳤다. 만들어진 코드를 검토해보자.

- 코드에 중복된 부분은 없는가?
- 코드가 무엇을 하는 것인지 이해하기 불편하지 않은가?
- 코드가 자신이 있어야 할 자리에 있는가?
- 앞으로 변경이 일어난다면 어떤 것이 있을 수 있고, 그 변화에 쉽게 대응할 수 있게 작성되어 있는가?


### upgradeLevels() 메소드 코드의 문제점

`upgradeLevels()` 메소드를 살펴보면 몇가지 문제점이 있다.
- if/elseif/else 블록들이 읽기 불편하다.
- 레벨의 변화 단계와 업그레이드 조건, 조건이 충족됐을 때 해야 할 작업이 한데 섞여 있다.
- 플래그를 두고 이를 마지막에 확인해서 업데이트를 진행하는 방법도 깔끔해 보이지 않는다.

성격이 다른 여러 가지 로직이 한데 섞여 있어서, 코드가 깔끔해보이지 않는다.

만약 새로운 레벨이 추가된다면, `Level` enum도 수정해야 하고, 업그레이드 로직을 담은 코드에 if 조건식과 블록을 추가해줘야 한다. 갈수록 이해하고 관리하기 힘들어질 것이다.

```java
// 현재 레벨이 무엇인지 파악 + 업그레이드 조건 이 함께 담겨져 있음
if (user.getLevel() == Level.BASIC && user.getLogin() >=50 ) {  
  // 다음 단계의 레벨이 무엇이며, 업그레이드를 위한 작업은 어떤 것인지
  user.setLevel(Level.SILVER);
  changed = true; // 부가 작업이 필요함을 알리기 위한 임시 플래그
}
...

if(changed) { userDao.update(user); }

```

### upgradeLevels() 리팩토링

`upgradeLevels()` 메소드는 자주 변경될 가능성이 있는 구체적인 내용이 추상적인 로직의 흐름과 함께 섞여 있다. 추상적인 레벨에서 로직을 작성해보자.

```java
public void upgradeLevels(){
  List<User> users = userDao.getAll();
  for (User user : users) {
      if(canUpgradeLevel(user)) {
          upgradeLevel(user);
      }
    }
}
```

구체적인 내용은 모르겠지만, `upgradeLevels()` 메소드가 어떤 작업을 하는지는 쉽게 이해할 수 있다.


이제 하나씩 구체적인 내용을 담은 메소드를 만들어 주면 된다.

- 업그레이드가 가능한지 알려주는 메소드인 `canUpgradeLevel()` 메소드는, 주어진 user에 대해 업그레이드가 가능하면 true, 아니면 false를 리턴한다. 상태에 따라서 업그레이드 조건만 비교하면 되므로, 역할과 책임이 명료해진다.

- 레벨 업그레이드를 위한 작업은 사용자의 레벨을 다음 단계로 바꿔주는 것과 변경사항을 DB에 업데이트해주는 것이다.

- 레벨의 순서와 다음 단계 레벨이 무엇인지를 결정하는 일은 `Level`에게 맡기자.

- 사용자 정보가 바뀌는 부분을 `UserService`에서 `User`로 옮기자. `User`의 내부 정보갑 ㅕㄴ경되는 것은 `UserService`보다는 `User`가 스스로 다루는 게 적절하다.




개선한 코드를 살펴보면 각 오브젝트와 메소드가 각각 자기 몫의 책임을 맡아 일을 하는 구조로 만들어졌음을 알 수 있을 것이다. `UserService`, `User`, `Level`이 내부 정보를 다루는 자신의 책임에 충실한 기능을 갖고 있으면서 필요가 생기면 이런 작업을 수행해달라고 서로 요청하는 구조다.  

각자 자기 책임에 충실한 작업만 하고 있으니 코드를 이해하기도 쉽고,   
변경이 필요할 때 어디를 수정해야 할지도 쉽게 알 수 있다.
잘못된 요청이나 작업을 시도했을 때, 이를 확인하고 예외를 던져줄 준비도 되어 있고,  
각각을 독립적으로 테스트하도록 만들면 테스트 코드도 단순해진다.  


### User 테스트

`User`에 간단하지만 로직을 담은 메소드를 추가했다. 앞으로 새로운 기능과 로직이 추가될 가능성이 있으니 테스트를 만들어두면 도움이 될 것이다.  

`User` 오브젝트는 스프링이 IoC로 관리해주는 오브젝트가 아니기 때문에, 스프링의 테스트 컨텍스트를 사용하지 않아도 된다.



### UserServiceTest 개선

기존의 `upgradeLevels()` 테스트 코드는 테스트 로직이 분명하게 드러나지 않는 것이 단점이었다. 각 사용자에 대해 업그레이드를 확인하려는 것인지 아닌지 이해하기 쉽게 개선해보자. 

또한 코드에 나타난 중복을 제거해보자. 업그레이드 조건인 로그인 횟수와 추천 횟수가 애플리케이션 코드와 테스트 코드에 중복돼서 나타난다. 이는 정수형 상수로 변경하자.
