5장에서는 지금까지 만든 DAO에 트랜잭션을 적용해보면서 스프링이 어떻게 성격이 비슷한 여러 종류의 기술을 추상화하고 이를 일관된 방법으로 사용할 수 있도록 지원하는지를 살펴볼 것이다.


# 5.1 사용자 레벨 관리 기능 추가

지금까지 만들었던 `UserDao`에 사용자의 활동내역을 참고해서 레벨을 조정해주는 기능을 넣어보자.

사용자 관리 기능에서 구현해야 할 비즈니스 로직은 다음과 같다.

- 사용자의 레벨은 BASIC, SILVER, GOLD 세 가지 중 하나다.
- 사용자가 처음 가입하면 BASIC 레벨이 되며, 이후 활동에 따라서 한 단계씩 업그레이드될 수 있다.
- 가입 후 50회 이상 로그인을 하면 BASIC에서 SILVER 레벨이 된다.
- SILVER 레벨이면서 30번 이상 추천을 받으면 GOLD 레벨이 된다.
- 사용자 레벨의 변경 작업은 일정한 주기를 가지고 일괄적으로 진행된다. 변경 작업 전에는 조건을 충족하더라도 레벨의 변경이 일어나지 않는다.


## 5.1.1 필드 추가

### Level enum
`User` 클래스에 사용자의 레벨을 저장할 필드를 추가하자.

- DB 에는 각 레벨을 코드화해서 숫자로 넣는다. DB 용량도 많이 차지하지 않고 가볍다.
- 자바의 `User`에는 숫자 타입을 직접 사용하는 것보다 enum을 이용하는 것이 안전하고 편리하다.
  - 숫자로 상수로 정의해 놓고 사용하면, 다른 종류의 정보를 넣는 실수를 해도 컴파일러가 체크해주지 못한다.

`Level` enum은 내부에는 DB에 저장할 int 타입의 값을 갖고 있지만, 겉으로는 `Level` 타입의 오브젝트이기 때문에 안전하게 사용할 수 있다.  

### User 필드 추가
`Level` 타입의 변수를 `User` 클래스, user DB에 추가하자.



### UserDaoTest 테스트 수정
`UserDaoJdbc`와 테스트에도 필드를 추가해야 한다. 테스트까지 갖추고 있는 안정된 코드이기 때문에, 기존 코드에 새로운 기능을 추가하려면 테스트를 먼저 만드는 것이 안전하다.


### JdbcDaoJdbc 수정
미리 준비된 테스트가 성공하도록 `UserDaoJdbc` 클래스를 수정한다.  




## 5.1.2 사용자 수정 기능 추가
수정할 정보가 담긴 `User` 오브젝트를 전달하면 id를 참고해서 사용자를 찾아 필드 정보를 UPDATE 문을 이용해 모두 변경해주는 메소드를 하나 만들자.

### 수정 기능 테스트 추가

픽스쳐 오브젝트를 하나 등록하고, id를 제외한 필드의 내용을 바꾼 뒤 `update()`를 호출한다.  
이제 다시 id로 조회해서 가져온 `User` 오브젝트와 수정한 픽스처 오브젝트를 비교하여 해당 id의 사용자 정보가 변경됐음을 확인하자.  

### UserDao와 UserDaoJdbc 수정
`UserDao` 인터페이스에 `update()` 메소드를 추가한다.


### 수정 테스트 보완
JDBC 개발에서 리소스 반환과 같은 기본 작업을 제외하면 가장 많은 실수가 일어나는 곳은 SQL 문장이다.

테스트로는 검증하지 못하는 오류가 있을 수 있는데, UPDATE 문장에서 WHERE 절을 빼먹는 경우이다.
update() 테스트에서 바뀐 로우의 내용만 확인해보면 정상적으로 동작한 것으로 보이지만,  
수정하지 않아야 할 로우의 내용이 그대로 남아 있는지 확인이 필요하다.

이 문제를 해결하려면 다음과 같은 방법이 있을 수 있다.

1. `JdbcTemplate`의 `update()`가 돌려주는 리턴 값을 확인한다.   
`JdbcTemplate`의 `update()`는 UPDATE나 DELETE 같이 테이블의 내용에 영향을 주는 SQL을 실행하면 영향받은 로우의 개수를 돌려주는데, `update()` 테스트라면 이 값이 1인지 확인하는 코드를 하나 더 추가해주면 된다.

2. 테스트를 보강해서 원하는 사용자 외의 정보는 변경되지 않았음을 직접 확인한다.  
사용자를 두 명 등록해놓고, 그중 하나만 수정한 뒤에 수정된 사용자와 수정하지 않은 사용자의 정보를 모두 확인하면 된다.

두번째를 적용하여, `update()` 메소드의 SQL에서 WHERE를 제외하고 테스트가 실패하는지도 함께 확인해보자.


## 5.1.3 UserService.upgradeLevels()

사용자 관리 로직은 어디다 두는 것이 좋을까? `UserDaoJdbc`는 데이터를 어떻게 가져오고 조작할지를 다루는 곳이지 비즈니스 로직을 두는 곳이 아니다.  

사용자 관리 비즈니스 로직을 담을 `UserService` 클래스를 추가하자.
`UserDao`의 구현 클래스가 바뀌어도 영향받지 않도록 해야 하므로, DAO의 인터페이스를 사용하고 DI를 적용한다.  DI를 적용하려면 당연히 `UserService`도 스프링 빈으로 등록돼야 한다.



### UserService 클래스와 빈 등록
`UserSer'` 클래스를 만들고 사용할 `UserDao` 오브젝트를 저장해둘 인스턴스 변수를 선언한다. 그리고 스프링 설정파일에 `userService` 아이디로 빈을 추가한다.

### UserServiceTest 테스트 클래스

`UserServiceTest` 클래스를 추가하고 테스트 대상인 `UserService` 빈을 제공받을 수 있도록 `@Autowired`가 붙은 인스턴스 변수로 선언해준다.

### upgradeLevels() 메소드
사용자 레벨 관리 기능을 먼저 만들고 테스트를 만들어보자.

### upgradeLevels() 테스트

테스트 방법은, 적어도 가능한 모든 조건을 하나씩은 확인해봐야 한다. 사용자 레벨은 BASIC, SILVER, GOLD 세 가지가 있고, 변경이 일어나지 않는 GOLD를 제외한 나머지는 두 가지 업그레이드가 되는 경우와 아닌 경우가 있을 수 있으므로 쵷소한 다섯 가지 경우를 살펴봐야 한다.  

다섯 종류의 사용자 정보를 등록해두고 업그레이드를 진행한 후에 예상한 대로 결과가 나오는지 확인해보자.


## 5.1.4 UserService.add()

요구사항 중 사용자 관리 비즈니스 로직에서 대부분은 구현했지만, 처음 가입하는 사용자의 레벨을 지정하는 부분이 남았다. 이 로직은 어디에 담는 것이 좋을까?

**`UserDaoJdbc`의 `add()` 메소드** : 적합하지 않다. `User` 오브젝트를 DB에 정보를 넣고 읽는 방법에만 관심을 가져야지, 비즈니스적인 의미를 지닌 정보를 설정하는 책임을 지는 것은 바람직하지 않다.   

**User클래스 level 필드를 Level.BASIC으로 초기화** : 처음 가입할 때를 제외하면 무의미한 정보이므로, 이 로직을 담기 위해 클래스에서 직접 초기화하는 것은 문제가 있다.


**UserService의 add() 메소드** : 사용자 정보를 담은 `User` 오브젝트를 받아서 DB에 넣어주는 데 충실한 역할을 한다면, `UserService`에도 `add()`를 만들어두고 사용자가 등록될 때 적용할 만한 비즈니스 로직을 담당하게 만든다.   단, level이 미리 설정되어 있을 수 있으므로, 설정된 경우와 설정되지 않은 경우 2 가지의 케이스를 분리하여 대응하도록 한다.



## 5.1.5 코드 개선

비즈니스 로직의 구현을 모두 마쳤다. 만들어진 코드를 검토해보자.

- 코드에 중복된 부분은 없는가?
- 코드가 무엇을 하는 것인지 이해하기 불편하지 않은가?
- 코드가 자신이 있어야 할 자리에 있는가?
- 앞으로 변경이 일어난다면 어떤 것이 있을 수 있고, 그 변화에 쉽게 대응할 수 있게 작성되어 있는가?


### upgradeLevels() 메소드 코드의 문제점

`upgradeLevels()` 메소드를 살펴보면 몇가지 문제점이 있다.
- if/elseif/else 블록들이 읽기 불편하다.
- 레벨의 변화 단계와 업그레이드 조건, 조건이 충족됐을 때 해야 할 작업이 한데 섞여 있다.
- 플래그를 두고 이를 마지막에 확인해서 업데이트를 진행하는 방법도 깔끔해 보이지 않는다.

성격이 다른 여러 가지 로직이 한데 섞여 있어서, 코드가 깔끔해보이지 않는다.

만약 새로운 레벨이 추가된다면, `Level` enum도 수정해야 하고, 업그레이드 로직을 담은 코드에 if 조건식과 블록을 추가해줘야 한다. 갈수록 이해하고 관리하기 힘들어질 것이다.

```java
// 현재 레벨이 무엇인지 파악 + 업그레이드 조건 이 함께 담겨져 있음
if (user.getLevel() == Level.BASIC && user.getLogin() >=50 ) {  
  // 다음 단계의 레벨이 무엇이며, 업그레이드를 위한 작업은 어떤 것인지
  user.setLevel(Level.SILVER);
  changed = true; // 부가 작업이 필요함을 알리기 위한 임시 플래그
}
...

if(changed) { userDao.update(user); }

```

### upgradeLevels() 리팩토링

`upgradeLevels()` 메소드는 자주 변경될 가능성이 있는 구체적인 내용이 추상적인 로직의 흐름과 함께 섞여 있다. 추상적인 레벨에서 로직을 작성해보자.

```java
public void upgradeLevels(){
  List<User> users = userDao.getAll();
  for (User user : users) {
      if(canUpgradeLevel(user)) {
          upgradeLevel(user);
      }
    }
}
```

구체적인 내용은 모르겠지만, `upgradeLevels()` 메소드가 어떤 작업을 하는지는 쉽게 이해할 수 있다.


이제 하나씩 구체적인 내용을 담은 메소드를 만들어 주면 된다.

- 업그레이드가 가능한지 알려주는 메소드인 `canUpgradeLevel()` 메소드는, 주어진 user에 대해 업그레이드가 가능하면 true, 아니면 false를 리턴한다. 상태에 따라서 업그레이드 조건만 비교하면 되므로, 역할과 책임이 명료해진다.

- 레벨 업그레이드를 위한 작업은 사용자의 레벨을 다음 단계로 바꿔주는 것과 변경사항을 DB에 업데이트해주는 것이다.

- 레벨의 순서와 다음 단계 레벨이 무엇인지를 결정하는 일은 `Level`에게 맡기자.

- 사용자 정보가 바뀌는 부분을 `UserService`에서 `User`로 옮기자. `User`의 내부 정보갑 ㅕㄴ경되는 것은 `UserService`보다는 `User`가 스스로 다루는 게 적절하다.




개선한 코드를 살펴보면 각 오브젝트와 메소드가 각각 자기 몫의 책임을 맡아 일을 하는 구조로 만들어졌음을 알 수 있을 것이다. `UserService`, `User`, `Level`이 내부 정보를 다루는 자신의 책임에 충실한 기능을 갖고 있으면서 필요가 생기면 이런 작업을 수행해달라고 서로 요청하는 구조다.  

각자 자기 책임에 충실한 작업만 하고 있으니 코드를 이해하기도 쉽고,   
변경이 필요할 때 어디를 수정해야 할지도 쉽게 알 수 있다.
잘못된 요청이나 작업을 시도했을 때, 이를 확인하고 예외를 던져줄 준비도 되어 있고,  
각각을 독립적으로 테스트하도록 만들면 테스트 코드도 단순해진다.  


### User 테스트

`User`에 간단하지만 로직을 담은 메소드를 추가했다. 앞으로 새로운 기능과 로직이 추가될 가능성이 있으니 테스트를 만들어두면 도움이 될 것이다.  

`User` 오브젝트는 스프링이 IoC로 관리해주는 오브젝트가 아니기 때문에, 스프링의 테스트 컨텍스트를 사용하지 않아도 된다.



### UserServiceTest 개선

기존의 `upgradeLevels()` 테스트 코드는 테스트 로직이 분명하게 드러나지 않는 것이 단점이었다. 각 사용자에 대해 업그레이드를 확인하려는 것인지 아닌지 이해하기 쉽게 개선해보자.

또한 코드에 나타난 중복을 제거해보자. 업그레이드 조건인 로그인 횟수와 추천 횟수가 애플리케이션 코드와 테스트 코드에 중복돼서 나타난다. 이는 정수형 상수로 변경하자.



# 5.2 트랜잭션 서비스 추상화

사용자 레벨 조정 작업은 중간에 문제가 발생해서 작업이 중단된다면 그때까지 진행된 변경 작업도 모두 취소시키도록 결정했다.



## 5.2.1 모 아니면 도

모든 사용자에 대해 업그레이드 작업을 진행하다가 중간에 예외가 발생해서 ㅈ가업이 중단된다면 어떻게 될까?

- 이미 변경된 사용자의 레벨은 작업 이전 상태로 돌아갈까?
- 바뀐 채로 남아 있을까?


테스트를 만들어 확인해보자. 장애가 발생했을 때 일어나는 현상 중의 하나인 예외가 던져지는 상황을 의도적으로 만들어보자.


### 테스트용 UserService 대역

어떻게 작업 중간에 예외를 강제로 만들 수 있을까?  
테스트용으로 특별히 `UserService`를 대신하여 테스트의 목적에 맞게 동작하는 클래스를 사용하자.

`UserService`를 상속해서 테스트에 필요한 기능을 추가하도록 일부 메소드를 오버라이딩 하는 방법을 적용하자.  
그리고 private으로 접근제한이 걸려 있는 `UserService` 메소드를 테스트를 위해 예외적으로 protected로 수정해서 상속을 통해 오버라이딩이 가능하게 하자.

### 강제 예외 발생을 통한 테스트


사용자 레벨 업그레이드를 시도하다가 중간에 예외가 발생했을 경우, 그 전에 업그레이드했던 사용자도 다시 원래 상태로 돌아갔는지를 확인한다.

두 번째 사용자의 레벨이 BASIC에서 SILVER로 바뀐 것이 네 번째 사용자 처리 중 예외가 발생했지만 그대로 유지되고 있는 것이다.



### 테스트 실패의 원인

왜 이런 결과가 나왔을까?

바로 트랜잭션 문제이다. `upgradeLevels()` 메소드가 하나의 트랜잭션 안에서 동작하지 않았기 때문이다.  

> **트랜잭션** 이란 더 이상 나눌 수 없는 단위 작업을 말한다. 작업을 쪼개서 작은 단위로 만들 수 없다는 것은, 트랜잭션의 핵심 속성인 원자성을 의미한다.


*이 작업도 더 이상 쪼개서 이뤄질 수 없는 원자와 같은 성질을 띤다.* 중간에 예외가 발생해서 작업을 완료할 수 없다면 아예 작업이 시작되지 않은 것처럼 초기 상태로 돌려놔야 한다.


`upgradeLevels()` 메소드의 작업은 트랜잭션이 적용되지 않았기 때문에 새로 추가된 기술 요건을 만족하지 못하고, 이를 검증하기 위해 만든 테스트가 실패하는 것이다.



## 5.2.2 트랜잭션 경계 설정

여러 DB작업이 하나의 트랜잭션이 되려면, 마지막 SQL이 성공적으로 DB에 수행되기 전에 문제가 발생할 경우에는 앞에서 처리한 SQL 작업도 취소시켜야 한다. 이런 취소 작업을 **트랜잭션 롤백(Transaction Rollback)** 이라고 한다.

반대로 여러 개의 SQL을 하나의 트랜잭션으로 처리하는 경우에 모든 SQL 수행 작업이 다 성공적으로 마무리됐다고 DB에 알려줘서 작업을 확정시켜야 한다. 이것을 **트랜잭션 커밋(Transaction Commit)** 이라고 한다.


### JDBC 트랜잭션의 트랜잭션 경계 설정

JDBC의 트랜잭션은 하나의 `Connection`을 가져와 사용하다가 닫는 사이에서 일어난다.  트랜잭션의 시작과 종료는 `Connection` 오브젝트를 통해 이뤄지기 때문이다.  JDBC에서 트랜잭션을 시작하려면 자동커밋 옵션을 false로 만들어주면 된다.

트랜잭션이 한 번 시작되면 `commit()` 또는 `rollback()` 메소드가 호출될 때까지의 작업이 하나의 트랜잭션으로 묶인다. `commit()` 또는 `rollback()`이 호출되면 그에 따라 작업 결과가 DB에  반영되거나 취소되고 트랜잭션이 종료된다.

> 이렇게 `setAutoCommit(false)`로 트랜잭션의 시작을 선언하고, `commit()` 또는 `rollback()`으로 트랜잭션을 종료하는 작업을 **트랜잭션의 경계설정(Transaction Demarcation)** 이라고 한다.


### UserService와 UserDao의 트랜잭션 문제

지금까지 만든 코드 어디에도 트랜잭션을 시작하고, 커밋하고, 롤백하는 트랜잭션 경계설정 코드가 존재하지 않는다.  

`JdbcTemplate`의 템플릿 메소드 호출 한 번에 한 개의 DB 커넥션이 만들어지고 닫히는 일까지 일어난다. `UserDao`는 `JdbcTemplate`을 통해 매번 새로운 DB 커넥션과 트랜잭션을 만들어 사용한다.   

데이터 액세스 코드를 DAO로 만들어서 분리해놓았을 경우에는 이처럼 DAO 메소드를 호출할 때마다 하나의 새로운 트랜잭션이 만들어지는 구조가 될 수밖에 없다.    
즉, `UserService` 내에서 진행되는 여러 가지 작업을 하나의 트랜잭션을 묶는 일이 불가능하다.

일련의 작업이 하나의 트랜잭션으로 묶이려면 그 작업이 진행되는 동안 DB커넥션도 하나만 사용돼야 하는데, 어떻게 할 수 있을까?


### 비즈니스 로직 내의 트랜잭션 경계 설정

- DAO 메소드 안으로 `upgradeLevels()` 메소드의 내용을 옮기는 방법
  - 비즈니스 로직과 데이터 로직을 한데 묶어버리는 결과를 초래한다.

- 트랜잭션의 경계 설정 작업을 `UserService` 쪽으로 가져온다.
  - 트랜잭션 시작과 종료를 담당하는 최소한의 코드만 가져오게 만들면 책임이 다른 코드를 분리해둔 채로 트랜잭션 문제를 해결할 수 있다.

### UserService 트랜잭션 경계설정의 문제점

`UserService`에서 커넥션을 생성하여 `UserDao`로 넘겨주는 식으로 수정하면 트랜잭션 문제는 해결할 수 있겠지만, 여러 문제가 발생한다.

1. DB 커넥션을 비롯한 리소스의 깔끔한 처리를 가능하게 했던 `JdbcTemplate`을 더 이상 활용할 수 없다.


2. 비즈니스 로직을 담고 있는 `UserService`의 메소드에 `Connection` 파라미터가 추가돼야 한다는 점이다.

3. `Connection` 파라미터가 `UserDao` 인터페이스 메소드에 추가되면 `UserDao`는 더 이상 데이터 액세스 기술에 독립적일 수가 없다.  

4. 테스트 코드에도 영향을 미친다.



## 5.2.3 트랜잭션 종기화

스프링은 멋진 해결 방법을 제공해준다.


### Connection 파라미터 제거

스프링은 독립적인 트랜잭션 동기화(Transaction synchronization) 방식을 제공한다. 트랜잭션 동기화란 `UserService`에서 트랜잭션을 시작하기 위해 만든 `Connection` 오브젝트를 특별한 저장소에 보관해두고, 이후에 호출되는 DAO의 메소드에서는 저장된 `Connection`을 가져다가 사용하게 하는 것이다.


트랜잭션 동기화 저장소는 작업 스레드마다 독립적으로 `Connection` 오브젝트를 저장하고 관리하기 떄문에 다중 사용자를 처리하는 서버의 멀티스레드 환경에서도 충돌이 날 염려는 없다.


이 방법을 사용하면, 일일이 `Connection` 오브젝트를 전달할 필요가 없어진다.


### 트랜잭션 동기화 적용

스프링은 트랜잭션 동기화 기능을 지원하는 간단한 유틸리티 메소드를 제공하고 있다.

스프링이 제공하는 트랜잭션 동기화 관리클래스는 `TransactionSynchronizationManager`이다.  
이 클래스를 이용해 먼저 트랜잭션 동기화 작업을 초기화하도록 요청하고,  
`DataSourceUtils`에서 제공하는 `getConnection()` 메소드를 통해 DB 커넥션을 생성한다.  
이 메소드는 `Connection` 오브젝트를 생성해줄 뿐만 아니라, 트랜잭션 동기화에 사용하도록 저장소에 바인딩해준다.   
트랜잭션 동기화가 되어 있는 채로, `JdbcTemplate`을 사용하면 `JdbcTemplate`의 작업에서 동기화시킨 DB 커넥션을 사용하게 된다. 결국 `UserDao`를 통해 진행되는 모든 JDBC 작업은 `upgradeLevels()` 메소드에서 만든 `Connection` 오브젝트를 사용하고 같은 트랜잭션에 참여하게 된다.


만약 예외가 발생하면 트랜잭션을 롤백해주고, 정상 수행되었으면 트랜잭션을 커밋해준다.



### JdbcTemplate과 트랜잭션 동기화

비즈니스 로직 레벨의 트랜잭션을 적용했지만 `JdbcTemplate`을 포기할 필요도 없고, 지저분한 `Connection` 파라미터를 계속 물고 다니지 않아도 된다. `UserDao`는 여전히 데이터 액세스 기술에 종속되지 않는 깔끔한 인터페이스 메소드를 유지하고 있다. 그리고 테스트에서 `DAO`를 직접 호출해서 사용하는 것도 아무런 문제가 되지 않는다.  

## 5.2.4 트랜잭션 서비스 추상화

### 기술과 환경에 종속되는 트랜잭션 경계설정 코드

현재는 DB 종류에 따라 트랜잭션 경계설정 코드를 재사용하지 못하는 상황이다.  여러 개의 DB에 트랜잭션 처리를 해야 한다거나, 다른 종류의 DB를 사용하는 `UserDao`에도 트랜잭션 관리 코드가 들어가야 하는 상황에 놓였다. 현재의 트랜잭션 경계 설정은 JDBC 기반으로 되어 있으므로, 각각의 기술에 맞게 코드를 변경할 수 밖에 없게 되었다.


### 트랜잭션 API의 의존관계 문제와 해결책

JDBC에 종속적인 `Connection`을 이용한 트랜잭션 코드가 `UserService`에 등장하면서부터 `UserService`는 `UserDaoJdbc`에 간접적으로 의존하는 코드가 돼버렸다.  

`UserService`의 코드가 특정 트랜잭션 방법에 의존적이지 않고 독립적일 수 있게 만들려면 어떻게 해야할까?   

트랜잭션의 경계설정을 담당하는 코드는 일정한 패턴을 갖는 유사한 구조이다. 이렇게 여러 기술의 사용 방법에 공통점이 있다면 추상화를 생각해볼 수 있다.  

JDBC, JTA, 하이버네이트, JPA, JDO, 심지어는 JMS도 트랜잭션 개념을 갖고 있으니 모두 그 트랜잭션 경계설정 방법에서 공통점이 있을 것이다. 이 공통적인 특징을 모아서 추상화된 트랜잭션 관리 계층을 만들 수 있다.



### 스프링의 트랜잭션 서비스 추상화

스프링은 트랜잭션 기술의 공통점을 담을 트랜잭션 추상화 기술을 제공하고 있다.  

`PlatformTransactionManager`은 스프링의 트랜잭션 경계설정을 위한 추상 인터페이스로, JDBC의 로컬 트랜잭션을 이용한다면 `DataSourceTransactionManager`을 사용하면 된다.  

`PlatformTransactionManager`에서는 트랜잭션을 가져오는 요청인 `getTransaction()` 메소드를 호출하기만 하면 트랜잭션을 시작할 수 있다.  
시작된 트랜잭션은 `TransactionStatus` 타입의 변수에 저장되고, 트랜잭션에 대한 조작이 필요할 때 `PlatformTransactionManager` 메소드의 파라미터로 전달해주면 된다.


### 트랜잭션 기술 서렂으이 분리

만약 JTA를 이용한 글로벌 트랜잭션으로 변경하려면 어떻게 해야 할까? 간단하다. `PlatformTransactionManager` 구현 클래스를 `JTATransactionManager`로 바꿔주기만 하면 된다.

하이버네이트로 `UserDao`를 구현하거나 JPA를 적용했다면 각각 알맞은 `PlatformTransactionManager` 구현체를 등록해주면 된다. 모두 `PlatformTransactionManager` 인터페이스를 구현한 것이니 트랜잭션 경계설정을 위한 `getTransaction()`, `commit()`, `rollback()` 메소드를 사용한 코드는 전혀 손댈 필요가 없다.  

하지만 어떤 트랜잭션 매니저 구현 클래스를 사용할지 `UserService` 코드가 알고 있는 것은 DI 원칙에 위배되는 것으로, 스프링 DI의 방식으로 바꾸자.


# 5.3 서비스 추상화와 단일 책임 원칙

스프링의 트랜잭션 서비스 추상화 기법을 이용해 다양한 트랜잭션 기술을 일관된 방식으로 제어할 수 있게 됐다.




### 수직, 수평 계층구조와 의존 관계

기술과 서비스에 대한 추상화 기법을 이용하면 특정 기술환경에 종속되지 않는 포터블한 코드를 만들 수 있다.  

- `UserDao`와 `UserService`는 같은 애플리케이션 로직을 담은 코드지만 내용에 따라 분리했다. => **수평적인 분리**

- 애플리케이션의 비즈니스 로직과 그 하위에서 동작하는 로우 레벨의 트랜잭션 기술이라는 다른 계층의 특성을 갖는 코드를 분리했다. => **수직적인 분리**


애플리케이션 로직의 종류에 따른 수평적인 구분이든, 로직과 기술이라는 수직적인 구분이든 모두 결합도가 낮으며, 서로 영향을 주지 않고 자유롭게 확장될 수 있는 구조를 만들 수 있는 데는 스프링의 DI가 중요한 역할을 한다. DI의 가치는 이렇게 **관심, 책임, 성격** 이 다른 코드를 깔끔하게 분리하는 데 있다.


### 단일 책임 원칙

이런 적절한 분리가 가져오는 특징은 **단일 책임 원칙** 으로 설명할 수 있다.
> *하나의 모듈은 한 가지 책임을 가져야 한다.*


`UserService`는 **어떻게 사용자 레벨을 관리할 것인가** 와 **어떻게 트랜잭션을 관리할 것인가** 라는 두 가지 책임을 갖고 있었다.

트랜잭션 서비스의 추상화 방식을 도입하고, 이를 DI를 통해 외부에서 제어하도록 만들고 나서는 **사용자 관리 로직이 바뀌거나 추가되지 않는 한** `UserService`의 코드에는 손댈 이유가 없다. 따라서 단일 책임 원칙을 충실하게 지키고 있다고 말할 수 있다.


### 단일 책임 원칙의 장점

단일 책임 원칙을 지키는 코드가 되면 어떤 장점이 있을까?

- 변경이 필요할 때 수정 대상이 명확해진다.


적절하게 책이모가 관심이 다른 코드를 분리하고, 서로 영향을 주지 않도록 다양한 추상화 기법을 도입학소, 애플리케이션 로직과 기술/환경을 분리하는 등의 작업은 엔터프라이즈 애플리케이션에서는 반드시 필요하다.  

그 과정에서, 스프링의 의존관계 주입 기술인 DI는 단일 책임 원칙뿐 아니라 개방 폐쇄 원칙도 잘 지키고, 모듈 간에 결합도가 낮아서 서로의 변경이 영향을 주지 않고, 변경이 단일 책임에 집중되는 응집도 높은 코드를 나오게 해준다.

DI는 스프링 기술의 기반이 되는 핵심 엔진이자 우너리이며, 스프링이 지지하고 지우너하는, 좋은 설계와 코드를 만드는 모든 과정에서 사용되는 가장 중요한 도구이다.  

> 스프링이 DI에 담긴 원칙과 이를 응용하는 프로그래밍 모델을 자바 엔터프라이즈 기술의 많은 문제를 해결하는 데 적극적으로 활용하고 있다.





















































#
