
복잡한 애플리케이션을 개발하는 데 필요한 도구 하나는 객체지향 기술이고, 다른 하나는 스프링이 강조하고 가치를 두고 있는 테스트다.

반복되는 변화에 대응하는 첫 번째 전략은 확장과 변화를 고려한 객체지향적 설계와 그것을 담아내는 IoC/DI 기술이고, 두 번째 전략은 테스트 기술이다.

테스트 기술은 만들어진 코드를 확신할 수 있게 해주고, 변화에 유연하게 대처할 수 있는 자신감을 준다.

스프링 개발자라면 테스트 작성 방법과 효과적으로 개발에 활용하는 전략을 알아야 하며, 실전에 적용할 수 있어야 한다.

또한 테스트의 작성은 스프링의 다양한 기술을 활용하는 방법을 이해하고 검증하고, 실전에 적용하는 방법을 익히는 데 효과적으로 사용될 수 있다.


# UserDaoTest 다시보기

## 2.1.1 테스트의 유용성

이전에 설계외 코드를 개선하고, 여러가지 변경 사항이 있을 때 최초 만들었던 기능을 잘 수행한다는 걸 테스트를 통해 화깅ㄴ할 수 없었다면, 코드를 개선하는 과정 내내 확신을 가질 수 없었을 것이다.

변경이 있을 때 처음과 동일한 기능을 수행함을 보장해줄 수 있는 방법은 직접 기능을 동작시켜서 결과를 확인하는 방법 외에는 없다.

절대로 머릿속의 시뮬레이션으로는 100% 확신할 수 없다.

*테스트* 란 결국 예상하고 의도했던 대로 코드가 정확히 동작하는지를 확인해서, 만든 코드를 확신할 수 있게 해주는 작업이다.

결과가 원하는 대로 나오지 않을 경우, 서비스 오픈 전에 코드나 설계에 결함이 있음을 알 수 있다. 테스트를 통해 디버깅을 거치고, 최종적으로 테스트가 성공하면 모든 결함이 제거됐다는 확신을 얻을 수 있다.


## 2.1.2 UserDaoTest의 특징

1장에서 만들었던 테스트 코드는 `main()`메소드를 이용해 쉽게 테스트 수행을 가능하게 했고, 테스트할 대상인 `UserDao`를 직접 호출해서 사용했다.




### 웹을 통한 DAO 테스트 방법의 문제점

웹 화면을 통해 값을 입력하고, 기능을 수행하고, 결과를 확인하는 방법은 가장 흔히 쓰이는 방법이지만, DAO에 대한 테스트로서는 단점이 너무 많다.

- DAO 뿐만 아니라 서비스 클래스, 컨트롤러, JSP 뷰 등 모든 레이어의 기능을 다 만들고 나서야 테스트가 가능하다.
- 에러가 발생했을 경우, 어디에서 문제가 발생했는지를 찾아내야 하는 수고도 필요하다.  
   - 정작 테스트할 대상인 DAO의 문제가 아니라, 서버 환경에서 웹 화면을 통해 DAO를 테스트하려고 만든 다른 코드 때문에 에러가 나거나 테스트를 실패할 수도 있다.

테스트하고 싶었던 건 `UserDao`였는데 다른 계층의 코드와 컴포넌트, 심지어 서버의 연결 상태까지 테스트에 영향을 줄 수 있기 때문에 이런 방식의 테스트는 번거롭고, 오류가 있을 때 빠르고 정확하게 대응하기가 힘들다.

어떻게 하면 이런 문제를 피할 수 있을까?


### 작은 단위의 테스트

테스트하고자 하는 대상이 명확하다면 그 대상에만 집중해서 테스트 하는 것이 바람직하다.

한꺼번에 너무 많은 것을 몰아서 테스트하면
- 테스트 수행 과정이 복잡해지고
- 오류가 발생했을 때 정확한 원인을 찾기가 힘들어진다.

따라서 테스트의 관심이 다르다면 테스트할 대상을 분리하고 집중해서 접근해야 한다.
> 관심사의 분리

이렇게 작은 단위의 코드에 대해 테스트를 수행한 것을 **단위 테스트** 라고 한다.
> 단위는 하나의 관심에 집중해서 효율적으로 테스트할 만한 범위의 단위


단위 테스트를 하는 이유는 개발자가 설계하고 만든 코드가 원래 의도한 대로 동작하는지를 개발자 스스로 빨리 확인받기 위해서다.
> 확인의 대상과 조건이 간단하고 명확할수록 좋다.

### 자동수행 테스트 코드

테스트는 자동으로 수행되도록 코드로 만들어지는 것이 중요하다.
> `UserDaoTest`가 `main()` 메소드를 실행하면 테스트가 되는 것처럼

자동으로 수행되는 테스트의 장점은 자주 반복할 수 있다.
언제든 코드를 수정하고 나서 테스트를 해볼 수 있기 때문에 마음에 확신을 얻을 수 있다.


### 지속적인 개선과 점진적인 개발을 위한 테스트

1장에서 가장 단순한 방법으로 DAO 로서의 기능에 문제가 없는지 검증해주는 테스트 코드를 만들어뒀기 때문에, 자신을 가지고 조금씩 코드를 개선해나가는 작업을 진행할 수 있었다.  
전체적으로 코드를 개선하는 작업에 속도가 붙고 더 쉬워졌을 수도 있다.

테스트를 이용하면 새로운 기능도 기대한 대로 동작하는지 확인할 수 있을 뿐만 아니라, 기존에 만들어뒀던 기능들이 추가된 코드에 영향을 받지 않고 여전히 잘 동착하는지 확인할 수도 있었다.


## 2.1.3 UserDaoTest의 문제점

`UserDaoTest`가 UI까지 동원되는 번거로운 수동 테스트에 비해 장점이 많은 건 사실이다. 하지만 만족스럽지 못한 부분도 있다.


**수동 확인 작업의 번거로움** 데이터의 준비를 모두 자동으로 진행하도록 만들어졌지만, 여전히 사람의 눈으로 확인하는 과정이 필요하다.  테스트의 결과를 확인하는 일은 사람의 책임이므로 완전히 자동으로 테스트되는 방법이라고 말할 수가 없다. 이는 불편하고, 실수를 할 가능성도 있다.

**실행 작업의 번거로움** 아무리 간단한 `main()` 메소드라고 하더라도 매번 그것을 실행하는 것은 번거롭다. DAO가 수백개가 된다면 전체 기능을 테스트 해보기 위해서는 `main()`메소드를 수백번 실행하는 수고가 필요하다. 또한 눈으로 결과를 확인하고 결과를 정리하려면 이것 또한 큰 작업이 된다.


# UserDaoTest 개선

## 2.2.1 테스트 검증의 자동화

모든 테스트는 성공과 실패의 두 가지 결과를 가질 수 있다.  

테스트의 실패는
**테스트 에러** : 테스트가 진행되는 동안에 에러가 발생해서 실패하는 경우
**테스트 실패** : 기대한 것과 다르게 나오는 경우
두 가지 결과를 가질 수 있다.

테스트 에러는 콘솔에 에러 메세지와 긴 호출 스택 정보가 출력되기 때문에 쉽게 확인이 가능하다.
하지만 테스트가 실패하는 것은 별도의 확인 작업과 그 결과가 있어야만 알 수 있다.

`UserDaoTest`는 `add()`에 전달한 `User` 오브젝트에 담긴 사용자 정보와 `get()`을 통해 다시 DB에서 가져온 `User` 오브젝트의 정보가 서로 정확히 일치하는가를 확인한다.
기존에는 단순히 콘솔에 출력하기만 했는데, 기대한 결과와 달라서 실패했을 경우에는 코드에서 직접 결과를 확인하여 "테스트 실패"라는 메세지를 출력하도록 만들어보자. 그리고 모든 확인 작업을 통과하면 그때는 "테스트 성공"이라고 출력하도록 한다.

이렇게 하면 테스트의 수행과 테스트 값의 적용, 그리고 결과를 검증하는 것까지 모두 자동화한 것이다. 할 일은 마지막 출력 메시지가 "테스트 성공"이라고 나오는지 확인하는 것뿐이다.

이 테스트는 `UserDao`의 기능이 정상적으로 동작하는지 언제든지 손쉽게 확인할 수 있게 해주며, 코드의 동작에 영향을 미칠 수 있는 어떤 변화라도 생기면 언제든지 다시 실행해볼 수 있다.

특히 포괄적인 테스트(Comprehensive Test, 만들어진 코드의 기능을 모두 점검)를 만들면서부터는, 과감한 수정을 한 후라도 테스트를 모두 돌려보고 나면 안심이 된다. 혹은 테스트를 통해 그 변경에 영향을 받는 부분이 정확히 확인된다면 빠르게 조치를 취할 수 있다.

빠르게 실행 가능하고 스스로 테스트 수행과 기대하는 결과에 대한 확인까지 해주는 코드로 된 자동화된 테스트를 만들어두면
- 코드 수정 시 마음의 평안을 얻고
- 코드에 대해 자신감을 가질 수 있다.



## 2.2.2 테스트의 효율적인 수행과 결과 관리

좀 더 편리하게 테스트를 수행하고 결과를 확인하려면 단순 `main()` 메소드로는 한계가 있다.
- 일정한 패턴을 가진 테스트를 만들 수 있고
- 많은 테스트를 간단히 실행시킬 수 있으며
- 테스트 결과를 종합해서 볼 수 있고,
- 테스트가 실패한 곳을 빠르게 찾을 수 있는 기능
을 갖춘 테스트 지원 도구와 그에 맞는 테스트 작성 방법이 필요하다.
`main()` 메소드를 이용한 방법만으로는 애플리케이션 규모가 커지고 테스트 개수가 많아지면 테스트를 수행하는 일이 점점 부담이 될 것이다. 



















# 개발자를 위한 테스팅 프레임워크 JUNIT
