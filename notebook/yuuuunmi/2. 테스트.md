
복잡한 애플리케이션을 개발하는 데 필요한 도구 하나는 객체지향 기술이고, 다른 하나는 스프링이 강조하고 가치를 두고 있는 테스트다.

반복되는 변화에 대응하는 첫 번째 전략은 확장과 변화를 고려한 객체지향적 설계와 그것을 담아내는 IoC/DI 기술이고, 두 번째 전략은 테스트 기술이다.

테스트 기술은 만들어진 코드를 확신할 수 있게 해주고, 변화에 유연하게 대처할 수 있는 자신감을 준다.

스프링 개발자라면 테스트 작성 방법과 효과적으로 개발에 활용하는 전략을 알아야 하며, 실전에 적용할 수 있어야 한다.

또한 테스트의 작성은 스프링의 다양한 기술을 활용하는 방법을 이해하고 검증하고, 실전에 적용하는 방법을 익히는 데 효과적으로 사용될 수 있다.


# UserDaoTest 다시보기

## 2.1.1 테스트의 유용성

이전에 설계외 코드를 개선하고, 여러가지 변경 사항이 있을 때 최초 만들었던 기능을 잘 수행한다는 걸 테스트를 통해 화깅ㄴ할 수 없었다면, 코드를 개선하는 과정 내내 확신을 가질 수 없었을 것이다.

변경이 있을 때 처음과 동일한 기능을 수행함을 보장해줄 수 있는 방법은 직접 기능을 동작시켜서 결과를 확인하는 방법 외에는 없다.

절대로 머릿속의 시뮬레이션으로는 100% 확신할 수 없다.

*테스트* 란 결국 예상하고 의도했던 대로 코드가 정확히 동작하는지를 확인해서, 만든 코드를 확신할 수 있게 해주는 작업이다.

결과가 원하는 대로 나오지 않을 경우, 서비스 오픈 전에 코드나 설계에 결함이 있음을 알 수 있다. 테스트를 통해 디버깅을 거치고, 최종적으로 테스트가 성공하면 모든 결함이 제거됐다는 확신을 얻을 수 있다.


## 2.1.2 UserDaoTest의 특징

1장에서 만들었던 테스트 코드는 `main()`메소드를 이용해 쉽게 테스트 수행을 가능하게 했고, 테스트할 대상인 `UserDao`를 직접 호출해서 사용했다.




### 웹을 통한 DAO 테스트 방법의 문제점

웹 화면을 통해 값을 입력하고, 기능을 수행하고, 결과를 확인하는 방법은 가장 흔히 쓰이는 방법이지만, DAO에 대한 테스트로서는 단점이 너무 많다.

- DAO 뿐만 아니라 서비스 클래스, 컨트롤러, JSP 뷰 등 모든 레이어의 기능을 다 만들고 나서야 테스트가 가능하다.
- 에러가 발생했을 경우, 어디에서 문제가 발생했는지를 찾아내야 하는 수고도 필요하다.  
   - 정작 테스트할 대상인 DAO의 문제가 아니라, 서버 환경에서 웹 화면을 통해 DAO를 테스트하려고 만든 다른 코드 때문에 에러가 나거나 테스트를 실패할 수도 있다.

테스트하고 싶었던 건 `UserDao`였는데 다른 계층의 코드와 컴포넌트, 심지어 서버의 연결 상태까지 테스트에 영향을 줄 수 있기 때문에 이런 방식의 테스트는 번거롭고, 오류가 있을 때 빠르고 정확하게 대응하기가 힘들다.

어떻게 하면 이런 문제를 피할 수 있을까?


### 작은 단위의 테스트

테스트하고자 하는 대상이 명확하다면 그 대상에만 집중해서 테스트 하는 것이 바람직하다.

한꺼번에 너무 많은 것을 몰아서 테스트하면
- 테스트 수행 과정이 복잡해지고
- 오류가 발생했을 때 정확한 원인을 찾기가 힘들어진다.

따라서 테스트의 관심이 다르다면 테스트할 대상을 분리하고 집중해서 접근해야 한다.
> 관심사의 분리

이렇게 작은 단위의 코드에 대해 테스트를 수행한 것을 **단위 테스트** 라고 한다.
> 단위는 하나의 관심에 집중해서 효율적으로 테스트할 만한 범위의 단위


단위 테스트를 하는 이유는 개발자가 설계하고 만든 코드가 원래 의도한 대로 동작하는지를 개발자 스스로 빨리 확인받기 위해서다.
> 확인의 대상과 조건이 간단하고 명확할수록 좋다.

### 자동수행 테스트 코드

테스트는 자동으로 수행되도록 코드로 만들어지는 것이 중요하다.
> `UserDaoTest`가 `main()` 메소드를 실행하면 테스트가 되는 것처럼

자동으로 수행되는 테스트의 장점은 자주 반복할 수 있다.
언제든 코드를 수정하고 나서 테스트를 해볼 수 있기 때문에 마음에 확신을 얻을 수 있다.


### 지속적인 개선과 점진적인 개발을 위한 테스트

1장에서 가장 단순한 방법으로 DAO 로서의 기능에 문제가 없는지 검증해주는 테스트 코드를 만들어뒀기 때문에, 자신을 가지고 조금씩 코드를 개선해나가는 작업을 진행할 수 있었다.  
전체적으로 코드를 개선하는 작업에 속도가 붙고 더 쉬워졌을 수도 있다.

테스트를 이용하면 새로운 기능도 기대한 대로 동작하는지 확인할 수 있을 뿐만 아니라, 기존에 만들어뒀던 기능들이 추가된 코드에 영향을 받지 않고 여전히 잘 동착하는지 확인할 수도 있었다.


## 2.1.3 UserDaoTest의 문제점

`UserDaoTest`가 UI까지 동원되는 번거로운 수동 테스트에 비해 장점이 많은 건 사실이다. 하지만 만족스럽지 못한 부분도 있다.


**수동 확인 작업의 번거로움** 데이터의 준비를 모두 자동으로 진행하도록 만들어졌지만, 여전히 사람의 눈으로 확인하는 과정이 필요하다.  테스트의 결과를 확인하는 일은 사람의 책임이므로 완전히 자동으로 테스트되는 방법이라고 말할 수가 없다. 이는 불편하고, 실수를 할 가능성도 있다.

**실행 작업의 번거로움** 아무리 간단한 `main()` 메소드라고 하더라도 매번 그것을 실행하는 것은 번거롭다. DAO가 수백개가 된다면 전체 기능을 테스트 해보기 위해서는 `main()`메소드를 수백번 실행하는 수고가 필요하다. 또한 눈으로 결과를 확인하고 결과를 정리하려면 이것 또한 큰 작업이 된다.


# UserDaoTest 개선

## 2.2.1 테스트 검증의 자동화

모든 테스트는 성공과 실패의 두 가지 결과를 가질 수 있다.  

테스트의 실패는
**테스트 에러** : 테스트가 진행되는 동안에 에러가 발생해서 실패하는 경우
**테스트 실패** : 기대한 것과 다르게 나오는 경우
두 가지 결과를 가질 수 있다.

테스트 에러는 콘솔에 에러 메세지와 긴 호출 스택 정보가 출력되기 때문에 쉽게 확인이 가능하다.
하지만 테스트가 실패하는 것은 별도의 확인 작업과 그 결과가 있어야만 알 수 있다.

`UserDaoTest`는 `add()`에 전달한 `User` 오브젝트에 담긴 사용자 정보와 `get()`을 통해 다시 DB에서 가져온 `User` 오브젝트의 정보가 서로 정확히 일치하는가를 확인한다.
기존에는 단순히 콘솔에 출력하기만 했는데, 기대한 결과와 달라서 실패했을 경우에는 코드에서 직접 결과를 확인하여 "테스트 실패"라는 메세지를 출력하도록 만들어보자. 그리고 모든 확인 작업을 통과하면 그때는 "테스트 성공"이라고 출력하도록 한다.

이렇게 하면 테스트의 수행과 테스트 값의 적용, 그리고 결과를 검증하는 것까지 모두 자동화한 것이다. 할 일은 마지막 출력 메시지가 "테스트 성공"이라고 나오는지 확인하는 것뿐이다.

이 테스트는 `UserDao`의 기능이 정상적으로 동작하는지 언제든지 손쉽게 확인할 수 있게 해주며, 코드의 동작에 영향을 미칠 수 있는 어떤 변화라도 생기면 언제든지 다시 실행해볼 수 있다.

특히 포괄적인 테스트(Comprehensive Test, 만들어진 코드의 기능을 모두 점검)를 만들면서부터는, 과감한 수정을 한 후라도 테스트를 모두 돌려보고 나면 안심이 된다. 혹은 테스트를 통해 그 변경에 영향을 받는 부분이 정확히 확인된다면 빠르게 조치를 취할 수 있다.

빠르게 실행 가능하고 스스로 테스트 수행과 기대하는 결과에 대한 확인까지 해주는 코드로 된 자동화된 테스트를 만들어두면
- 코드 수정 시 마음의 평안을 얻고
- 코드에 대해 자신감을 가질 수 있다.



## 2.2.2 테스트의 효율적인 수행과 결과 관리

좀 더 편리하게 테스트를 수행하고 결과를 확인하려면 단순 `main()` 메소드로는 한계가 있다.
- 일정한 패턴을 가진 테스트를 만들 수 있고
- 많은 테스트를 간단히 실행시킬 수 있으며
- 테스트 결과를 종합해서 볼 수 있고,
- 테스트가 실패한 곳을 빠르게 찾을 수 있는 기능
을 갖춘 테스트 지원 도구와 그에 맞는 테스트 작성 방법이 필요하다.
`main()` 메소드를 이용한 방법만으로는 애플리케이션 규모가 커지고 테스트 개수가 많아지면 테스트를 수행하는 일이 점점 부담이 될 것이다.


### JUnit 테스트로 전환
JUnit은 자바 테스팅 프레임워크다. 프레임워크는 개발자가 만든 클래스에 대한 제어 권한을 넘겨받아서 주도적으로 애플리케이션의 흐름을 제어한다. 개발자가 만든 클래스의 오브젝트를 생성하고 실행하는 일은 프레임워크에 의해 진행된다. 그러므로 `main()` 도 필요 없고, 오브젝트를 만들어서 실행시키는 코드를 만들 필요도 없다.


### 테스트 메소드 전환
테스트가 `main()` 메소드로 만들어졌다는 건 제어권을 직접 갖는다는 의미이다. 그래서 `main()` 메소드에 있던 테스트 코드를 일반 메소드로 옮기고 JUnit 프레임워크가 요구하는 조건 두 가지를 따라야 한다.
- 메소드가 public
- 메소드에 @Test 애노테이션

`main()` 대신에 일반 메소드를 만들고 테스트의 의도가 무엇인지 알 수 있는 이름을 붙여준다.

### 검증 코드 전환

테스트의 결과를 검증하는 if/else 문장을 JUnit이 제공하는 방법을 이용해 전환해보자.
Jnit에서는 `assertThat`이라는 스태틱 메소드를 이용해 다음과 같이 변경할 수 있다.

```java
assertThat(user2.getName(), is(user.getName()));
```

`assertThat()` 메소드는 첫 번째 파라미터의 값을 뒤에 나오는 매처(matcher)라고 불리는 조건으로 비교해서 일치하면 다음으로 넘어가고, 아니면 테스트가 실패하도록 만들어준다.  
`is`는 매처의 일종으로 `equals`로 비교해주는 기능을 가졌다.


Junit은 테스트를 실행하고 나면 테스트 결과를 다양한 방법으로 알려주므로, "테스트 성공"이라는 메세지를 굳이 출력할 필요는 없다.



### JUnit 테스트 실행

JUnit 프레임워크를 이용해 만든 테스트 메소드를 실행하도록 `main()` 메소드를 하나 추가하고, 그 안에 JUnitCore 클래스의 main 메소드를 호출해주는 간단한 코드를 넣어보자. 스프링 컨테이너와 마찬가지로 JUnit 프레임워크도 자바 코드로 만들어진 프로그램이므로 어디선가 한 번은 해당 프레임워크를 시작시켜 줘야 한다.

JUnit은 `assertThat()`을 이용해 검증을 했을 때 기대한 결과가 아니면 이 `AssertionError`을 던진다. 따라서 `assertThat()`의 조건을 만족하지 못하면 테스트는 더 이상 진행되지 않고 JUnit은 테스트가 실패했음을 알게 된다. 테스트 수행 중에 일반 예외가 발생한 경우에도 테스트 수행은 중단되고 테스트는 실패한다.




# 개발자를 위한 테스팅 프레임워크 JUNIT

JUnit은 자바 표준 테스팅 프레임워크라고 불릴 만큼 폭넓게 사용되고 있고, 스프링 프레임워크 자체도 JUnit 프레임워크를 이용해 테스트를 만들어가며 개발됐다.

스프링 테스트 모듈도 JUnit을 이용한다. 따라서 스프링의 기능을 익히기 위해서라도 JUnit은 꼭 사용할 줄 알아야 한다. 대부분의 자바 IDE는 JUnit 테스트를 손쉽게 실행할 수 있는 JUnit 테스트 지원 기능을 내장하고 있어서 편리하게 테스트를 만들고 활용할 수 있게 해준다.

## 2.3.1 JUnit 테스트 실행 방법

### IDE - IntelliJ 에서 패키지 전체 테스트 하기

- Run > Edit Configurations... > Add New Configuration > JUnit
- Test kind 를 All in package 로 지정하고, Package 명 입력하여 실행

![image](https://user-images.githubusercontent.com/13299177/78464807-a6429500-7728-11ea-8a9c-3a69aaf358e9.png)


### 빌드 툴
ANT, 메이븐, Gradle 같은 빌드 툴과 스크립트를 사용하면 빌드 툴에서 제공하는 JUnit 플러그인이나 테스크를 이용해 JUnit 테스트를 실행할 수 있다.



## 2.3.2 테스트 결과의 일관성


지금까지 테스트를 실행하면서 가장 불편했던 일은, 매번 `UserDaoTest` 테스트를 실행하기 전에 DB의 USER 테이블 데이터를 모두 삭제해줘야 할 때였다.

테스트가 외부 상태에 따라 성공하기도 하고 실패하기도 하는 상태인데, 별도의 준비 작업 없이는 성공해야 마땅한 테스트가 실패하기도 한다는 점이다.  
반복적으로 테스트를 했을 때 테스트가 실패하기도 하고 성공하기도 한다면 이는 좋은 테스트라고 할 수가 없다. 코드에 변경사항이 없다면 테스트는 항상 동일한 결과를 내야 한다.

`UserDaoTest`의 문제는 이전 테스트 때문에 DB에 등록된 중복 데이터가 있을 수 있다는 점으로, `addAndGet()` 테스트를 마치고 나면 테스트가 등록한 사용자 정보를 삭제해서, 테스트를 수행하기 이전 상태로 만들어주는 것이다. 그렇다면 항상 동일한 결과를 얻을 수 있다.

### deleteAll()의 getCount() 추가

일관성 있는 결과를 보장하는 테스트를 만들기 위해 새로운 기능을 추가한다.

**deleteAll** USER 테이블의 모든 레코드를 삭제해주는 `deleteAll()` 메소드를 만든다.   
**getCount()** USER 테이블의 레코드 개수를 돌려주는 `getCount()` 메소드이다.


### deleteAll()과 getCount()의 테스트

기존의 `addAndGet()` 테스트를 확장하여 새로 만든 `deleteAll()`과 `getCount()`의 메소드를 테스트 해보자.  `addAndGet()` 테스트는 시작 전 수동으로 USER 테이블의 내용을 모두 삭제해줘야 했으므로, 테스트가 시작될 때 실행해주도록 하자.

`deleteAll()`가 기대한 대로 동작한다면, `getCount()` 로 레코드 개수를 가져올 경우 0이 나와야 한다. 그러므로 `deleteAll()`을 실행한 직후에 `getCount()`의 결과값을 검증하고 코드를 넣어보자.

`getCount()`는 어떻게 확인할 수 있을까? `add()` 메소드가 정상적으로 DB에 데이터를 넣는 것을 확인했으니, `add()` 수행하고 `getCount()`를 호출하고 나면 값이 증가하는지 확인해보자.


### 동일한 결과를 보장하는 테스트

여러번 반복해서 테스트를 실행해도, 테이블을 삭제하지 않았음에도 정상적으로 테스트가 성공한다. 어떤 상황에도 반복적으로 실행된다고 하더라도 동일한 결과가 나올 수 있게 된 것이다.

**단위 테스트** 는 코드가 바뀌지 않는다면 *매번 실행할 때마다 동일한 테스트 결과* 를 얻을 수 있어야 한다. 외부 환경에 영향을 받지 말아야 하는 것은 물론이고, 테스트를 실행하는 순서를 바꿔도 동일한 결과가 보장되도록 만들어야 한다.


테스트를 완료하고 마지막에 `deleteAll()`을 하면 안될까?
-> 테스트 이전에 들어가 있는 데이터가 있을 수 있기 때문에, 테스트 실행에 문제가 되지 않는 상태를 만들어 주는 편이 더 낫다.

## 2.3.3 포괄적인 테스트

두 개 이상의 레코드를 `add()` 했을 때는 `getCount()`의 실행 결과가 어떻게 될까?

### getCount() 테스트

테스트 메소드는 한 번에 한 가지 검증 목적에만 충실한 것이 좋다. 그러므로 `getCount()`를 위한 새로운 테스트 메소드를 만들어 테스트하면 별문제 없이 성공할 것이다.

> 테스트들은 어떤 순서로 실행될지는 알 수 없다. 만약 실행 순서에 영향을 받는다면 테스트를 잘못 만든 것이다.


### addAndGet() 테스트 보완

`get()` 메소드가 주어진 id에 해당하는 정확한 User 정보를 가져오는지 확인할 수 있도록 기능을 보완하여 `addAndGet()` 테스트 코드를 만들어보자.

### get() 예외조건에 대한 테스트

만약 `get()` 메소드에 전달된 id 값에 해당하는 사용자 정보가 없다면 어떤 결과가 나오면 좋을까?
- null 과 같은 특별한 값을 리턴
- id에 해당하는 정보를 찾을 수 없다고 예외를 던짐

`UserDao`의 `get()` 메소드에서 쿼리를 실행한 결과 값이 아무것도 없으면 예외를 던지도록 만들어보자.
그 전에, 테스트 코드로 어떻게 예외를 기대할 수 있도록 만들수 있을까?

일반적으로 예외가 던져지면 테스트 메소드의 실행은 중단되고 테스트는 실패한다. (테스트 에러)

그런데 테스트 진행 중에 특정 예외가 던져지면 테스트가 성공한 것이고, 예외가 던져지지 않고 정상적으로 작업을 마치면 테스트가 실패했다고 판단해야 한다. 문제는 리턴 값을 비교하는 방법으로는 확인할 수 없다.

이런 경우를 위해 JUnit에서는 @Test 애노테이션의 `expected` 엘리먼트를 사용한다. `expected`는 테스트 메소드 실행 중에 발생하리라 기대하는 예외 클래스를 넣어주면 된다.

### 테스트를 성공시키기 위한 코드의 수정

`get()` 메소드를 주어진 id에 해당하는 데이터가 없으면 `EmptyResultDataAccessException`을 던지도록 수정하고, 테스트가 성공하는지 확인하자.


### 포괄적인 테스트
DAO의 메소드에 대한 포괄적인 테스트를 만들어두는 편이 훨씬 안전하고 유용하다.

테스트를 만들 때 성공하는 테스트만 골라서 만드는 실수를 종종한다. 하지만 부정적인 케이스를 먼저 만드는 습관을 들이는 게 좋다. 존재하지 않는 id가 주어졌을 때는 어떻게 반응할지를 먼저 결정하고, 이를 확인할 수 있는 테스트를 먼저 만들려고 한다면 예외적인 상황을 빠뜨리지 않는 꼼꼼한 개발이 가능하다.
