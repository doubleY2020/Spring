
1장에서 개방 폐쇄 원칙을 적용하기 위해 관심이 다른 코드를 분리하고, 확장과 변경에 용이하게 대응할 수 있는 설계구조로 개선하는 작업을 하였다.

> 개방 폐쇄 원칙 : 확장에는 자유롭게 열려 있고, 변경에는 굳게 닫혀 있다.

**개팡 폐쇄 원칙** 은 코드에서 2가지 성질이 있음을 말해준다.
- 어떤 부분은 변경을 통해 그 **기능이 다양해지고 확장** 하려는 성질
- 어떤 부분은 고정되어 있고 **변하지 않는 성질**

각각 **다른 목적** 과 **다른 이유** 에 의해 **다른 시점** 에 *독립적으로 변경* 될 수 있는 효율적인 구조를 만들어 주는 것이 개방 폐쇄 원칙인데,

**템플릿** 이란
1. 변경이 거의 일어나지 않고 일정한 패턴으로 유지되는 특성을 가진 부분을
2. 자유롭게 변경되는 성질을 가진 부분으로 부터 독립시켜서
*개방 폐쇄 원칙을 효과적으로 활용할 수 있도록 하는 방법* 이다.


# 3.1 다시 보는 초난감 DAO

`UserDao` 코드는 예외상황에 대한 처리를 해주지 않았다.

## 3.1.1 예외처리 기능을 갖춘 DAO

제한적인 리소스(DB 커넥션)를 공유해 사용하는 서버에서 동작하는 코드는
어떤 이유로든 예외가 발생했을 경우 반드시 사용한 리소스를 반환하도록 만들어야 한다.
그렇지 않으면 시스템에 심각한 문제를 일으킬 수 있다.

### JDBC 수정, 조회 기능의 예외처리 코드

`deleteAll()` 메소드에서 `PreparedStatement`를 처리하던 중에 예외가 발생하면 어떻게 될까?  
메소드 실행을 끝마치지 못하고 바로 메소드를 빠져나가게 되는데,  
이때 문제는 `Connection`과 `PreparedStatement`의 `close()` 메소드가 실행되지 않아서 제대로 리소스가 반환되지 않을 수 있다는 점이다.

일반적으로 서버에서는 제한된 개수의 DB 커넥션을 만들어서 재사용 가능한 풀로 관리하는데, DB 풀은 매번 `getConnection()`으로 가져간 커넥션을 명시적으로 `close()` 해서 돌려줘야지만 다시 풀에 넣었다가 다음 커넥션 요청이 있을 때 재사용할 수 있다.   
이런 식으로 오류가 날 때마다 미처 반환되지 못한 `Connection`이 계속 쌓이면 어느 순간에 커넥션 풀에 여유가 없어지고 리소스가 모자란다는 심각한 오류를 내며 서버가 중단될 수 있다.

그래서 JDBC 코드에서는 어떤 상황에서도 가져온 리소스를 반환하도록 try/catch/finally 구문 사용을 권장하고 있다.  


















# 3.2 변하는 것과 변하지 않는 것


# 3.3 JDBC 전략 패턴의 최적화

# 3.4 컨텍스트와 DI
