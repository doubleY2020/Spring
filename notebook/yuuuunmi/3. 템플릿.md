
1장에서 개방 폐쇄 원칙을 적용하기 위해 관심이 다른 코드를 분리하고, 확장과 변경에 용이하게 대응할 수 있는 설계구조로 개선하는 작업을 하였다.

> 개방 폐쇄 원칙 : 확장에는 자유롭게 열려 있고, 변경에는 굳게 닫혀 있다.

**개팡 폐쇄 원칙** 은 코드에서 2가지 성질이 있음을 말해준다.
- 어떤 부분은 변경을 통해 그 **기능이 다양해지고 확장** 하려는 성질
- 어떤 부분은 고정되어 있고 **변하지 않는 성질**

각각 **다른 목적** 과 **다른 이유** 에 의해 **다른 시점** 에 *독립적으로 변경* 될 수 있는 효율적인 구조를 만들어 주는 것이 개방 폐쇄 원칙인데,

**템플릿** 이란
1. 변경이 거의 일어나지 않고 일정한 패턴으로 유지되는 특성을 가진 부분을
2. 자유롭게 변경되는 성질을 가진 부분으로 부터 독립시켜서
*개방 폐쇄 원칙을 효과적으로 활용할 수 있도록 하는 방법* 이다.


# 3.1 다시 보는 초난감 DAO

`UserDao` 코드는 예외상황에 대한 처리를 해주지 않았다.

## 3.1.1 예외처리 기능을 갖춘 DAO

제한적인 리소스(DB 커넥션)를 공유해 사용하는 서버에서 동작하는 코드는
어떤 이유로든 예외가 발생했을 경우 반드시 사용한 리소스를 반환하도록 만들어야 한다.
그렇지 않으면 시스템에 심각한 문제를 일으킬 수 있다.

### JDBC 수정, 조회 기능의 예외처리 코드

`deleteAll()` 메소드에서 `PreparedStatement`를 처리하던 중에 예외가 발생하면 어떻게 될까?  
메소드 실행을 끝마치지 못하고 바로 메소드를 빠져나가게 되는데,  
이때 문제는 `Connection`과 `PreparedStatement`의 `close()` 메소드가 실행되지 않아서 제대로 리소스가 반환되지 않을 수 있다는 점이다.

일반적으로 서버에서는 제한된 개수의 DB 커넥션을 만들어서 재사용 가능한 풀로 관리하는데, DB 풀은 매번 `getConnection()`으로 가져간 커넥션을 명시적으로 `close()` 해서 돌려줘야지만 다시 풀에 넣었다가 다음 커넥션 요청이 있을 때 재사용할 수 있다.   
이런 식으로 오류가 날 때마다 미처 반환되지 못한 `Connection`이 계속 쌓이면 어느 순간에 커넥션 풀에 여유가 없어지고 리소스가 모자란다는 심각한 오류를 내며 서버가 중단될 수 있다.

그래서 JDBC 코드에서는 어떤 상황에서도 가져온 리소스를 반환하도록 try/catch/finally 구문 사용을 권장하고 있다.  



# 3.2 변하는 것과 변하지 않는 것

## 3.2.1 JDBC try/catch/finally 코드의 문제점

복잡한 try/catch/finally 코드를 훑어보면 한숨부터 나온다. 블록 중첩에 모든 메소드마다 반복되는 코드가 나타난다.

이런 코드 작성시 흔히 복붙을 사용하게 되는데, 속도를 내서 작업하다가 어느 순간 한 줄 빼먹고 복사했거나, 몇 줄 잘못 삭제하게 되면 알아채기 쉽지 않은 오류를 큰 사고가 나기 전까지 발견하기 힘들다.

누군가 DAO 로직을 수정하려고 했을 때 복잡한 try/catch/finally 블록 안에서 필요한 부분을 찾아서 수정해야 하고, 언젠가 꼭 필요한 부분을 잘못 삭제해버리면 역시 같은 문제가 반복된다.

이런 코드를 효과적으로 다루기 위해서는 많은 곳에서 중복되는 코드와 로직에 따라 자꾸 확장되고 자주 변하는 코드를 잘 분리해내는 작업이 필요하다.  
1장과 비슷한 문제이기 때문에 같은 방법(중복 메소드 추출)으로 접근하면 되지만, 해결 방법이 조금 다르다.

## 3.2.2 분리와 재사용을 위한 디자인 패턴 적용

가장 먼저 할 일은 변하는 성격이 다른 것을 찾아내는 것이다.

`PreparedStatement`를 만들어서 업데이트용 쿼리를 실행하는 메소드라면 `deleteAll()` 메소드와 구조는 거의 비슷할 것이다.   
비슷한 기능의 메소드에서 동일하게 나타날 수 있는 변하지 않고 고정되는 부분과,  
각 메소드마다 로직에 따라 변하는 부분을 구분해볼 수 있다.  

코드에서는 어떻게 분리할 수 있을까?

- 변하지 않는 부분 : try/catch/finally
- 변하는 부분 : PreparedStatement

### 메소드 추출

먼저 생각해볼 수 있는 방법은 변하는 부분을 메소드로 빼는 것이다.

변하지 않는 부분이 변하는 부분을 감싸고 있어서 변하지 않는 부분을 추추랗기가 어려워보이기 때문에 변하는 부분을 추출하는 방법을 해 보았지만, 별 이득이 없다.

주로 메소드 추출 리팩토링을 적용하는 경우에는 분리시킨 메소드를 다른 곳에서 재사용할 수 있어야 하는데,  
이건 반대로 **분리시키고 남은 메소드** 가 **재사용이 필요한 부분** 이고, **분리된 메소드** 는 DAO **로직마다 새롭게 만들어서 확장돼야 하는 부분** 이기 떄문이다.  반대로 됐다.

- 변하지 않는 부분(재사용이 필요한 부분) : **분리시키고 남은 메소드**
- 변하는 부분(로직마다 새롭게 만들어서 확장돼야 하는 부분) : **분리된 메소드**

### 템플릿 메소드 패턴의 적용

템플릿 메소드 패턴을 이용해서 분리해보자.  

**템플릿 메소드 패턴** 은 상속을 통해 기능을 확장해서 사용하는 부분이다.  
**변하지 않는 부분** 은 **슈퍼클래스** 에 두고, **변하는 부분** 은 추상 메소드로 정의해둬서 서브클래스에서 오버라이드하여 새롭게 정의해 쓰도록 하는 것이다.

고정된 JDBC try/catch/finally 블록을 가진 슈퍼클래스 메소드와  
필요에 따라 상속을 통해 구체적인 `PreparedStatement`를 바꿔서 사용할 수 있게 만드는 서브클래스로 깔끔하게 분리할 수 있다.

**장점** `UserDao` 클래스의 기능을 확장하고 싶을 때마다 상속을 통해 자유롭게 확장할 수 있고, 기존의 상위 DAO 클래스에 불필요한 변화는 생기지 않도록 할 수 있으니 개방 폐쇄 원칙을 그럭저럭 잘 지키게 되었다.   
**단점** DAO 로직마다 상속을 통해 새로운 클래스를 만들어야 한다. 또한 확장구조가 클래스를 설계하는 시점에서 고정되어 버려, 관계에 대한 유연성이 떨어진다.


- 변하지 않는 부분 : **슈퍼클래스 메소드**
- 변하는 부분 : 슈퍼 클래스의 추상 메소드 -> **서브클래스 에서 오버라이드**


### 전략 패턴의 적용

OCP(개방 폐쇄 원칙)를 잘 지키는 구조이면서 템플릿 메소드 패턴보다 유연하고 확장성이 뛰어난 것이  
오브젝트를 아예 둘로 분리하고, 클래스 레벨에서는 **인터페이스를 통해서만 의존** 하도록 만드는 **전략 패턴** 이다.    

**전략 패턴** OCP 관점에서 보았을 때 확장에 해당하는 변하는 부분을 별도 클래스로 만들어 추상화된 인터페이스(변하지 않는 부분)를 통해 위임하는 방식이다.

- 변하지 않는 부분 : 컨텍스트
- 변하는 부분 : 전략

`deleteAll()` 에서의 전략은 `PreparedStatement`를 만들어주는 외부 기능이 바로 전략 패턴에서 말하는 전략이라고 볼 수 있다.  전략 패턴의 구조를 따라 이 기능을 인터페이스로 만들어두고 인터페이스의 메소드를 통해 `PreparedStatement` 생성 전략을 호출해주면 된다.  `PreparedStatement`를 생성하는 전략을 호출할 때는 이 컨텍스트 내에서 만들어둔 DB 커넥션을 전달해야 한다.


하지만 전략 패턴은 컨텍스트는 그대로 유지되면서 전략을 바꿔 쓸 수 있다는 것인데,  
컨텍스트 안에서 **인터페이스가 아닌 구체적인 전략 클래스 `DeleteAllStatement`를 사용하도록 고정** 되어 있다면, 전략 패턴에 OCP가 잘 들어맞는다고 볼 수 없다.  


### DI 적용을 위한 클라이언트/컨텍스트 분리

전략 패턴에 따르면 Context가 어떤 전략을 사용하게 할 것인가는 Context를 사용하는 앞단의 Client가 결정하는 게 일반적이다.  
Client가 구체적인 전략의 하나를 선택하고 오브젝트를 만들어서 Context에 전달하는 것이다.  
Context는 전달받은 그 Strategy 구현 클래스의 오브젝트를 사용한다.  

중요한 부분은 컨텍스트에 해당하는 JDBC try/catch/finally 코드를 클라이언트 코드인 `StateStrategy`를 만드는 부분에서 독립시켜야 한다는 점이다.  

`deleteAll()` 메소드에서 전략을 생성하는 부분은 클라이언트에 들어가고, 나머지 코드는 컨텍스트 코드이므로 별도 메소드로 독립시켜보자.  

1. 컨텍스트는 클라이언트로부터 전략 타입 오브젝트를 제공받는다.
2. 컨텍스트 내에서 작업을 수행하면서, 제공받은 전략 오브젝트를 필요한 시점에 호출해서 사용한다.

컨텍스트 내 전략 오브젝트는 인터페이스에 선언된 메소드를를 호출하기 때문에 구체적인 구현체를 알 필요가 없다.  
클라이언트는 구체적인 전략이 담긴 오브젝트(변하는 부분)를 생성하고 컨텍스트(공통 메소드)에 전략 오브젝트와 함께 작업을 요청하는 것 외에 변하지 않는 부분에 대해서는 관심을 가지지 않는다.


의존관계와 책임으로 볼 때 이상적인 클라이언트/컨텍스트 관계를 갖고 있으며, 클라이언트가 컨텍스트가 사용할 전략을 정해서 전달한다는 면에서 DI구조라고 이해할 수도 있다.  




# 3.3 JDBC 전략 패턴의 최적화

지금까지 기존의 `deleteAll()` 메소드에 담겨 있던 변하지 않는 부분, 자주 변하는 부분을 전략 패턴을 사용해 깔끔하게 분리해냈다.  
독립적인 JDBC 작업 흐름이 담긴 jdbcContextStatementStrategy()는 DAO 메소드들이 공유할 수 있게 됐다.  

## 3.3.1 전략 클래스의 추가 정보

이번엔 `add()` 메소드에도 적용해보자.

`deleteAll()`과는 달리 `add()`에서는 `PreparedStatement`를 만들 때 user라는 부가적인 정보가 필요하다. 등록할 사용자 정보는 클라이언트에 해당하는 `add()` 메소드가 갖고 있기 때문에, 클라이언트가 `AddStatement`의 전략을 수행하기 위해 부가정보 user를 제공해줘야 한다.  
클라이언트로부터 `User` 타입 오브젝트를 받을 수 있도록 `AddStatement`의 생성자를 통해 제공받게 만들자.  



## 3.3.2 전략과 클라이언트의 동거

두 가지 불만이 있다.

1. DAO 메소드마다 새로운 `StatementStrategy` 구현 클래스를 만들어야 한다.
2. `User`처럼 부가적인 정보가 있는 경우, 이를 위해 오브젝트를 전달받는 생성자와 이를 저장해둘 인스턴스 변수를 번거롭게 만들어야 한다는 점이다.


### 로컬 클래스
클래스 파일이 많아지는 문제는 `StatementStrategy` 전략 클래스를 매번 독립된 파일로 만들지 말고 `UserDao` 클래스 안에 내부 클래스로 정의해버리는 것이다.  

메소드마다 추가해야 했던 클래스 파일 하나 줄일 수 있고, 내부 클래스의 특징을 이용해 로컬 변수를 바로 가져다 사용할 수 있다.

### 익명 내부 클래스

`AddStatement` 클래스는 add() 메소드에서만 사용할 용도로 만들어졌기 떄문에, 클래스 이름 조차 필요 없는 익명 내부 클래스로 선언해보자.  





# 3.4 컨텍스트와 DI


## 3.4.1 JdbcContext의 분리


클라이언트 : `UserDao` 메소드   
전략 : 익명 내부 클래스  
컨텍스트 : `jdbcContextStatementStrategy()` 메소드  

컨텍스트 메소드(`jdbcContextStatementStrategy()`)는 일반적인 JDBC의 작업 흐름을 담고 있어서, `UserDao` 말고 다른 DAO 에서도 사용 가능하다.  
그러므로 모든 DAO가 사용할 수 있게 해보자.


### 클래스 분리

분리해서 만든 클래스의 이름은 `JdbcContext` 이다.
DB 커넥션을 필요로 하는 코드는 이제 `UserDao`가 아닌 `JdbcContext` 이므로, `JdbcContext`가 `DataSource` 타입 빈을 DI 받을 수 있도록 수정한다.

`UserDao`는 `DataSource` 대신 `JdbcContext`를 주입받도록 수정한다.


### 빈 의존관계 변경
`UserDao`는 이제 `JdbcContext`에 의존하고 있다.  

`JdbcContext`는 인터페이스인 `DataSource`와 달리 구체 클래스다.  스프링의 DI는 기본적으로 인터페이스를 사이에 두고 의존 클래스를 바꿔서 사용하도록 하는 게 목적이다.  
하지만 `JdbcContext`는 그 자체로 독립적인 JDBC 컨텍스트를 제공해주는 서비스 오브젝트로서 의미가 있을 뿐이고, 구현 방법이 거의 바뀔 가능성은 없다.  

`UserDao`와 `JdbcContext`는 인터페이스를 사이에 두지 않고 DI를 적용하는 특별한 구조가 되었다.  

해당 의존관계에 따라서 XML 파일을 수정하자. 
