
1장에서 개방 폐쇄 원칙을 적용하기 위해 관심이 다른 코드를 분리하고, 확장과 변경에 용이하게 대응할 수 있는 설계구조로 개선하는 작업을 하였다.

> 개방 폐쇄 원칙 : 확장에는 자유롭게 열려 있고, 변경에는 굳게 닫혀 있다.

**개팡 폐쇄 원칙** 은 코드에서 2가지 성질이 있음을 말해준다.
- 어떤 부분은 변경을 통해 그 **기능이 다양해지고 확장** 하려는 성질
- 어떤 부분은 고정되어 있고 **변하지 않는 성질**

각각 **다른 목적** 과 **다른 이유** 에 의해 **다른 시점** 에 *독립적으로 변경* 될 수 있는 효율적인 구조를 만들어 주는 것이 개방 폐쇄 원칙인데,

**템플릿** 이란
1. 변경이 거의 일어나지 않고 일정한 패턴으로 유지되는 특성을 가진 부분을
2. 자유롭게 변경되는 성질을 가진 부분으로 부터 독립시켜서
*개방 폐쇄 원칙을 효과적으로 활용할 수 있도록 하는 방법* 이다.


# 3.1 다시 보는 초난감 DAO

`UserDao` 코드는 예외상황에 대한 처리를 해주지 않았다.

## 3.1.1 예외처리 기능을 갖춘 DAO

제한적인 리소스(DB 커넥션)를 공유해 사용하는 서버에서 동작하는 코드는
어떤 이유로든 예외가 발생했을 경우 반드시 사용한 리소스를 반환하도록 만들어야 한다.
그렇지 않으면 시스템에 심각한 문제를 일으킬 수 있다.

### JDBC 수정, 조회 기능의 예외처리 코드

`deleteAll()` 메소드에서 `PreparedStatement`를 처리하던 중에 예외가 발생하면 어떻게 될까?  
메소드 실행을 끝마치지 못하고 바로 메소드를 빠져나가게 되는데,  
이때 문제는 `Connection`과 `PreparedStatement`의 `close()` 메소드가 실행되지 않아서 제대로 리소스가 반환되지 않을 수 있다는 점이다.

일반적으로 서버에서는 제한된 개수의 DB 커넥션을 만들어서 재사용 가능한 풀로 관리하는데, DB 풀은 매번 `getConnection()`으로 가져간 커넥션을 명시적으로 `close()` 해서 돌려줘야지만 다시 풀에 넣었다가 다음 커넥션 요청이 있을 때 재사용할 수 있다.   
이런 식으로 오류가 날 때마다 미처 반환되지 못한 `Connection`이 계속 쌓이면 어느 순간에 커넥션 풀에 여유가 없어지고 리소스가 모자란다는 심각한 오류를 내며 서버가 중단될 수 있다.

그래서 JDBC 코드에서는 어떤 상황에서도 가져온 리소스를 반환하도록 try/catch/finally 구문 사용을 권장하고 있다.  



# 3.2 변하는 것과 변하지 않는 것

## 3.2.1 JDBC try/catch/finally 코드의 문제점

복잡한 try/catch/finally 코드를 훑어보면 한숨부터 나온다. 블록 중첩에 모든 메소드마다 반복되는 코드가 나타난다.

이런 코드 작성시 흔히 복붙을 사용하게 되는데, 속도를 내서 작업하다가 어느 순간 한 줄 빼먹고 복사했거나, 몇 줄 잘못 삭제하게 되면 알아채기 쉽지 않은 오류를 큰 사고가 나기 전까지 발견하기 힘들다.

누군가 DAO 로직을 수정하려고 했을 때 복잡한 try/catch/finally 블록 안에서 필요한 부분을 찾아서 수정해야 하고, 언젠가 꼭 필요한 부분을 잘못 삭제해버리면 역시 같은 문제가 반복된다.

이런 코드를 효과적으로 다루기 위해서는 많은 곳에서 중복되는 코드와 로직에 따라 자꾸 확장되고 자주 변하는 코드를 잘 분리해내는 작업이 필요하다.  
1장과 비슷한 문제이기 때문에 같은 방법(중복 메소드 추출)으로 접근하면 되지만, 해결 방법이 조금 다르다.

## 3.2.2 분리와 재사용을 위한 디자인 패턴 적용

가장 먼저 할 일은 변하는 성격이 다른 것을 찾아내는 것이다.

`PreparedStatement`를 만들어서 업데이트용 쿼리를 실행하는 메소드라면 `deleteAll()` 메소드와 구조는 거의 비슷할 것이다.   
비슷한 기능의 메소드에서 동일하게 나타날 수 있는 변하지 않고 고정되는 부분과,  
각 메소드마다 로직에 따라 변하는 부분을 구분해볼 수 있다.  

코드에서는 어떻게 분리할 수 있을까?

- 변하지 않는 부분 : try/catch/finally
- 변하는 부분 : PreparedStatement

### 메소드 추출

먼저 생각해볼 수 있는 방법은 변하는 부분을 메소드로 빼는 것이다.

변하지 않는 부분이 변하는 부분을 감싸고 있어서 변하지 않는 부분을 추출하기가 어려워보이기 때문에 변하는 부분을 추출하는 방법을 해 보았지만, 별 이득이 없다.

주로 메소드 추출 리팩토링을 적용하는 경우에는 분리시킨 메소드를 다른 곳에서 재사용할 수 있어야 하는데,  
이건 반대로 **분리시키고 남은 메소드** 가 **재사용이 필요한 부분** 이고, **분리된 메소드** 는 DAO **로직마다 새롭게 만들어서 확장돼야 하는 부분** 이기 떄문이다.  반대로 됐다.

- 변하지 않는 부분(재사용이 필요한 부분) : **분리시키고 남은 메소드**
- 변하는 부분(로직마다 새롭게 만들어서 확장돼야 하는 부분) : **분리된 메소드**

### 템플릿 메소드 패턴의 적용

템플릿 메소드 패턴을 이용해서 분리해보자.  

**템플릿 메소드 패턴** 은 상속을 통해 기능을 확장해서 사용하는 부분이다.  
**변하지 않는 부분** 은 **슈퍼클래스** 에 두고, **변하는 부분** 은 추상 메소드로 정의해둬서 서브클래스에서 오버라이드하여 새롭게 정의해 쓰도록 하는 것이다.

고정된 JDBC try/catch/finally 블록을 가진 슈퍼클래스 메소드와  
필요에 따라 상속을 통해 구체적인 `PreparedStatement`를 바꿔서 사용할 수 있게 만드는 서브클래스로 깔끔하게 분리할 수 있다.

**장점** `UserDao` 클래스의 기능을 확장하고 싶을 때마다 상속을 통해 자유롭게 확장할 수 있고, 기존의 상위 DAO 클래스에 불필요한 변화는 생기지 않도록 할 수 있으니 개방 폐쇄 원칙을 그럭저럭 잘 지키게 되었다.   
**단점** DAO 로직마다 상속을 통해 새로운 클래스를 만들어야 한다. 또한 확장구조가 클래스를 설계하는 시점에서 고정되어 버려, 관계에 대한 유연성이 떨어진다.


- 변하지 않는 부분 : **슈퍼클래스 메소드**
- 변하는 부분 : 슈퍼 클래스의 추상 메소드 -> **서브클래스 에서 오버라이드**


### 전략 패턴의 적용

OCP(개방 폐쇄 원칙)를 잘 지키는 구조이면서 템플릿 메소드 패턴보다 유연하고 확장성이 뛰어난 것이  
오브젝트를 아예 둘로 분리하고, 클래스 레벨에서는 **인터페이스를 통해서만 의존** 하도록 만드는 **전략 패턴** 이다.    

**전략 패턴** OCP 관점에서 보았을 때 확장에 해당하는 변하는 부분을 별도 클래스로 만들어 추상화된 인터페이스(변하지 않는 부분)를 통해 위임하는 방식이다.

- 변하지 않는 부분 : 컨텍스트
- 변하는 부분 : 전략

`deleteAll()` 에서의 전략은 `PreparedStatement`를 만들어주는 외부 기능이 바로 전략 패턴에서 말하는 전략이라고 볼 수 있다.  전략 패턴의 구조를 따라 이 기능을 인터페이스로 만들어두고 인터페이스의 메소드를 통해 `PreparedStatement` 생성 전략을 호출해주면 된다.  `PreparedStatement`를 생성하는 전략을 호출할 때는 이 컨텍스트 내에서 만들어둔 DB 커넥션을 전달해야 한다.


하지만 전략 패턴은 컨텍스트는 그대로 유지되면서 전략을 바꿔 쓸 수 있다는 것인데,  
컨텍스트 안에서 **인터페이스가 아닌 구체적인 전략 클래스 `DeleteAllStatement`를 사용하도록 고정** 되어 있다면, 전략 패턴에 OCP가 잘 들어맞는다고 볼 수 없다.  


### DI 적용을 위한 클라이언트/컨텍스트 분리

전략 패턴에 따르면 Context가 어떤 전략을 사용하게 할 것인가는 Context를 사용하는 앞단의 Client가 결정하는 게 일반적이다.  
Client가 구체적인 전략의 하나를 선택하고 오브젝트를 만들어서 Context에 전달하는 것이다.  
Context는 전달받은 그 Strategy 구현 클래스의 오브젝트를 사용한다.  

중요한 부분은 컨텍스트에 해당하는 JDBC try/catch/finally 코드를 클라이언트 코드인 `StateStrategy`를 만드는 부분에서 독립시켜야 한다는 점이다.  

`deleteAll()` 메소드에서 전략을 생성하는 부분은 클라이언트에 들어가고, 나머지 코드는 컨텍스트 코드이므로 별도 메소드로 독립시켜보자.  

1. 컨텍스트는 클라이언트로부터 전략 타입 오브젝트를 제공받는다.
2. 컨텍스트 내에서 작업을 수행하면서, 제공받은 전략 오브젝트를 필요한 시점에 호출해서 사용한다.

컨텍스트 내 전략 오브젝트는 인터페이스에 선언된 메소드를를 호출하기 때문에 구체적인 구현체를 알 필요가 없다.  
클라이언트는 구체적인 전략이 담긴 오브젝트(변하는 부분)를 생성하고 컨텍스트(공통 메소드)에 전략 오브젝트와 함께 작업을 요청하는 것 외에 변하지 않는 부분에 대해서는 관심을 가지지 않는다.


의존관계와 책임으로 볼 때 이상적인 클라이언트/컨텍스트 관계를 갖고 있으며, 클라이언트가 컨텍스트가 사용할 전략을 정해서 전달한다는 면에서 DI구조라고 이해할 수도 있다.  




# 3.3 JDBC 전략 패턴의 최적화

지금까지 기존의 `deleteAll()` 메소드에 담겨 있던 변하지 않는 부분, 자주 변하는 부분을 전략 패턴을 사용해 깔끔하게 분리해냈다.  
독립적인 JDBC 작업 흐름이 담긴 jdbcContextStatementStrategy()는 DAO 메소드들이 공유할 수 있게 됐다.  

## 3.3.1 전략 클래스의 추가 정보

이번엔 `add()` 메소드에도 적용해보자.

`deleteAll()`과는 달리 `add()`에서는 `PreparedStatement`를 만들 때 user라는 부가적인 정보가 필요하다. 등록할 사용자 정보는 클라이언트에 해당하는 `add()` 메소드가 갖고 있기 때문에, 클라이언트가 `AddStatement`의 전략을 수행하기 위해 부가정보 user를 제공해줘야 한다.  
클라이언트로부터 `User` 타입 오브젝트를 받을 수 있도록 `AddStatement`의 생성자를 통해 제공받게 만들자.  



## 3.3.2 전략과 클라이언트의 동거

두 가지 불만이 있다.

1. DAO 메소드마다 새로운 `StatementStrategy` 구현 클래스를 만들어야 한다.
2. `User`처럼 부가적인 정보가 있는 경우, 이를 위해 오브젝트를 전달받는 생성자와 이를 저장해둘 인스턴스 변수를 번거롭게 만들어야 한다는 점이다.


### 로컬 클래스
클래스 파일이 많아지는 문제는 `StatementStrategy` 전략 클래스를 매번 독립된 파일로 만들지 말고 `UserDao` 클래스 안에 내부 클래스로 정의하는 것으로 해결할 수 있다.

메소드마다 추가해야 했던 클래스 파일 하나 줄일 수 있고, 내부 클래스의 특징을 이용해 로컬 변수를 바로 가져다 사용할 수 있는 이점이 있다.

### 익명 내부 클래스

`AddStatement` 클래스는 add() 메소드에서만 사용할 용도로 만들어졌기 떄문에, 클래스 이름 조차 필요 없는 익명 내부 클래스로 선언하면 더 간단하다.





# 3.4 컨텍스트와 DI


## 3.4.1 JdbcContext의 분리


> 클라이언트 : `UserDao` 메소드   
> 전략 : 익명 내부 클래스  
> 컨텍스트 : `jdbcContextStatementStrategy()` 메소드  


컨텍스트 메소드(`jdbcContextStatementStrategy()`)는 일반적인 JDBC의 작업 흐름을 담고 있어서, `UserDao` 말고 다른 DAO 에서도 사용 가능하다.  
그러므로 모든 DAO가 사용할 수 있게 해보자.


### 클래스 분리

분리해서 만든 클래스의 이름은 `JdbcContext` 이다.
DB 커넥션을 필요로 하는 코드는 이제 `UserDao`가 아닌 `JdbcContext` 이므로, `JdbcContext`가 `DataSource` 타입 빈을 DI 받을 수 있도록 수정한다.

`UserDao`는 `DataSource` 대신 `JdbcContext`를 주입받도록 수정한다.


### 빈 의존관계 변경
`UserDao`는 이제 `JdbcContext`에 의존하고 있다.  

`JdbcContext`는 인터페이스인 `DataSource`와 달리 구체 클래스다.  스프링의 DI는 기본적으로 인터페이스를 사이에 두고 의존 클래스를 바꿔서 사용하도록 하는 게 목적이다.  
하지만 `JdbcContext`는 그 자체로 독립적인 JDBC 컨텍스트를 제공해주는 서비스 오브젝트로서 의미가 있을 뿐이고, 구현 방법이 거의 바뀔 가능성은 없다.  

`UserDao`와 `JdbcContext`는 인터페이스를 사이에 두지 않고 DI를 적용하는 특별한 구조가 되었다.  

해당 의존관계에 따라서 XML 파일을 수정하자.



## 3.4.2 JdbcContext의 특별한 DI

`UserDao`와 `JdbcContext` 사이에는 인터페이스를 사용하지 않고 DI를 적용했다.   
지금까지 적용했던 DI에서는 클래스 레벨에서 구체적인 의존관계가 만들어지지 않도록 인터페이스를 사용했는데,  
인터페이스를 사용하지 않고 DI를 적용하는 것은 문제가 있지 않을까?

> 인터페이스로 DI를 적용하면 구체적인 의존관계가 만들어지지 않아 다양한 의존 오브젝트를 변경해서 사용할 수 있다.


### 스프링 빈으로 DI

스프링 DI 의도에 맞게 인터페이스로 뽑아내어 정의해두고, `UserDao`에서 사용하게 해야하지 않을까 싶지만, 꼭 그럴 필요는 없다. (물론 그렇게 해도 상관은 없다.)

의존관계 주입의 충실한 개념은,
1. 인터페이스를 사이에 둬서 클래스 레벨에서는 의존관계가 고정되지 않게 하고,
2. 런타임 시에 의존할 오브젝트와의 관계를 다이나믹하게 주입해주는 것이 맞다.

따라서 인터페이스를 하용하지 않았다면 엄밀히 말해서 온전한 DI라고 볼 수 없다.

하지만 DI는 넓게 보면, *객체의 생성과 관계 설정에 대한 제어권한을 오브젝트에서 제거하고 외부로 위임했다* 라는 IoC 개념을 포괄한다.  
그런 의미에서 `JdbcContext`를 스프링을 이용해 `UserDao` 객체에서 사용하게 주입했다는 것은 DI의 기본을 따르고 있다고 볼 수 있다.


인터페이스를 사용해서 클래스를 자유롭게 변경할 수 있게 하지는 않았지만, `JdbcContext`를 `UserDao`와 DI 구조로 만들어야 할 이유를 생각해보자.

**1. JdbcContext가 스프링 컨테이너의 싱클톤 레지스트리에서 관리되는 싱글톤 빈이 되기 때문이다.**  
`JdbcContext`는 JDBC 컨텍스트 메소드를 제공해주는 일종의 서비스 오브젝트로서 의미가 있고, 싱글톤으로 등록돼서 여러 오브젝트에서 공유해 사용되는 것이 이상적이다.  
> `JdbcContext`는 그 자체로 변경되는 상태 정보를 갖고 있지 않다.


**2. JdbcContext가 DI를 통해 다른 빈에 의존하고 있기 때문이다.**  
DI를 위해서는 주입되는 오브젝트와 주입받는 오브젝트 양쪽 모두 스프링 빈으로 등록돼야 한다.  따라서 `JdbcContext`는 다른 빈을 DI 받기 위해서라도 스프링 빈으로 등록돼야 한다.



왜 인터페이스를 사용하지 않았을까?  
인터페이스를 사용하지 않았다는 것은 `UserDao`와 `JdbcContext`가 매우 긴밀한 관계를 가지고 강하게 결합되어 있다는 의미이다. (비록 클래스는 구분되어 있지만 강한 응집도를 가지고 있다.)  

굳이 인터페이스를 두지 말고 강력한 결합을 가진 관계를 허용하면서, 싱글톤으로 만드는 것과 `JdbcContext`에 대한 DI 필요성을 위해 `JdbcContext`를 스프링의 빈으로 등록해서 `UserDao`에 DI 되도록 만들어도 괜찮다.


단, 클래스를 바로 사용하는 코드 구성을 DI에 적용하는 것은 가장 마지막 단계에서 고려해볼 사항임을 잊지 말자.




### 코드를 이용하는 수동 DI

`JdbcContext`를 스프링의 빈으로 등록해서 `UserDao`에 DI 하는 대신 사용할 수 있는 방법은 `UserDao` 내부에서 직접 DI를 적용하는 방법이다.


이 방법은 스프링의 빈으로 등록해서 사용했던 **첫번째 이유** 인 **싱글톤** 으로 만들려는 것은 포기해야 한다.
`UserDao`가 `JdbcContext`의 생성과 초기화의 제어권을 갖게 한다.  

> DAO마다 하나의 `JdbcContext`를 갖고 있게 하는 것이다   


남은 문제는, 스프링의 빈으로 등록해서 사용했던 **두번째 이유** 이다. `JdbcContext`는 `DataSource` 타입 빈을 다이내믹하게 **주입받아서 사용해야 한다.**

해결할 수 있는 방법은, `JdbcContext`에 대한 제어권을 갖고 생성과 관리를 담당하는 `UserDao`에게 DI까지 맡기는 것이다.  

`JdbcContext`에 주입해줄 의존 오브젝트인 `DataSource`는 `UserDao`가 대신 DI 받도록 하고, `UserDao`는 주입받은 `DataSource` 빈을 `JdbcContext`를 만들고 초기화하는 과정에만 사용하고 버린다.

설정파일만 보자면 `UserDao`가 직접 `DataSource`를 의존하고 있는 것 같지만, 내부적으로는 `JdbcContext`를 통해 간접적으로 `DataSource`를 사용하고 있을 뿐이다.  

이 방법의 장점은 긴밀한 관계를 갖는 DAO클래스와 `JdbcContext`를 **어색하게 따로 빈으로 분리하지 않고**, 내부에서 직접 만들어 사용하면서도 **다른 오브젝트에 대한 DI를 적용할 수 있다** 는 점이다.

<br>


**인터페이스를 사용하지 않는 클래스와의 의존관계이지만 스프링의 DI를 이용하기 위해 빈으로 등록하여 사용하는 방법** 은 오브젝트 사이의 실제 의존관계가 설정파일에 명확하게 드러난다는 장점이 있지만, DI의 근본적인 원칙에 부합하지 않는 구체적인 클래스와의 관계가 설정에 직접 노출된다는 단점이 있다.


**DAO의 코드를 이용해 수동으로 DI를 하는 방법** 은 내부에서 만들어지고 사용되면서 그 관계를 외부에는 드러내지 않는다는 장점이 있지만, `JdbcContext`를 여러 오브젝트가 사용하더라도 싱글톤으로 만들 수 없고, DI 작업을 위한 부가적인 코드가 필요하다는 단점도 있다.

<br>

어떤 방법이 더 낫다고 말할 수는 없다. 상황에 따라 적절하다고 판단되는 방법을 사용해야 하고, 그에 따른 선택의 이유와 근거가 분명히 있어야 한다.

# 3.5 템플릿과 콜백

전략 패턴의 기본 구조에 익명 내부 클래스를 활용한 방식을 스프링에서는 **템플릿/콜백** 패턴이라 부른다.
- 컨텍스트 : 템플릿
- 익명 내부 클래스로 만들어진 오브젝트 : 콜백

## 3.5.1 템플릿/콜백의 동작원리

템플릿 : **고정된 작업 흐름** 을 가진 코드를 **재사용** 한다.  
콜백 : 템플릿 안에서 호출되는 것을 목적으로 만들어진 오브젝트를 말한다.

### 템플릿/콜백의 특징

- 전략 패턴의 전략과 달리 템플릿/콜백 패턴의 콜백은 보통 단일 메소드 인터페이스를 사용하며, 익명 내부 클래스로 만들어진다.
  - 특정 기능을 위해 한 번 호출되는 경우가 일반적임
- 보통 콜백 인터페이스의 메소드에는 컨텍스트 정보를 전달받는 파라미터가 있다.
  - `JdbcContext`에서는 템플릿인 `workWithStatementStrategy()` 메소드 내에서 생성한 `Connection` 오브젝트를 콜백의 메소드인 `makePreparedStatement()`를 실행할 때 파라미터로 넘겨준다. `PreparedStatement`를 만들기 위해서는 JDBC 컨텍스트/템플릿 안에서 만들어진 DB 커넥션이 필요하기 떄문이다.
  > ??? 왜 `PreparedStatement`가 아닌 `Connection` 오브젝트라고 말하는거지??  
  > A) 템플릿 메소드(컨텍스트)에서는 파라미터를 실행할 때 콜백 메소드(인터페이스 오브젝트, 전략)에게 넘겨준다. client는 콜백 메소드(전략)를 상황에 따라 정의한다.   
```java
public void deleteAll() throws SQLException {
    // client 에서 전략을 정의한다. 전략을 정의할 때 주입받은 Connection 오브젝트를 사용한다.
    // client 가 템플릿 메소드를 호출할 때 콜백을 파라미터로 전달한다.
    this.jdbcContext.workWithStatementStrategy(c -> c.prepareStatement(
                "delete from users"));
}
```    
```java
public interface StatementStrategy {
    // 템플릿에서 콜백 메소드인 makePreparedStatement()를 실행할 때 Connection 오브젝트를 넘겨준다.
    PreparedStatement makePreparedStatement(Connection c) throws SQLException;
}
```  
```java
public class JdbcContext {
    private DataSource dataSource;
    public void workWithStatementStrategy(StatementStrategy stmt) throws SQLException {
        Connection c = null;
        PreparedStatement ps = null;
        try {
            c = this.dataSource.getConnection();
            // makePreparedStatement()를 실행할 때 Connection 오브젝트를 넘겨준다.
            ps = stmt.makePreparedStatement(c);
            // ...
        }
    }
}  
```

- 흐름
  1. 클라이언트는 템플릿 안에서 실행될 로직을 담은 콜백 오브젝트를 만들고, 콜백이 참조할 정보를 제공한다. 콜백은 클라이언트가 템플릿 메소드를 호출할 때 파라미터로 전달된다.
  2. 템플릿은 정해진 작업 흐름을 진행하다가 내부에서 생성한 참조정보(전략 인터페이스)를 가지고 콜백 오브젝트의 메소드를 호출한다. 콜백은 클라이언트 메소드에 있는 정보와 템플릿이 제공한 참조 정보를 이용해서 작업을 수행하고 그 결과를 다시 템플릿에 돌려준다.
  3. 템플릿은 콜백이 돌려준 정보를 사용해서 작업을 마저 수행한다. 최종 결과를 클라이언트에 다시 돌려주기도 한다.

- 클라이언트가 템플릿 메소드를 호출하면서 콜백 오브젝트를 전달하는 것은 메소드 레벨에서 일어나는 DI이다.
  - 일반적인 DI : 템플릿에 인스턴스 변수를 만들어두고 사용할 의존 오브젝트를 수정자 메소드로 받아서 사용하는 것
  - 템플릿/콜백 방식의 DI : 매번 메소드 단위로 사용할 오브젝트를 새롭게 전달받고, 콜백 오브젝트가 자신을 생성한 클라이언트 메소드 내의 정보를 직접 참조한다. 또한 클라이언트와 콜백이 강하게 결합된다.


### JdbcContext에 적용된 템플릿/콜백

`JdbcContext`의 `workWithStatementStrategy()` 템플릿은 리턴 값이 없는 단순한 구조다. 흐름이 더 복잡한 경우에는 한 번 이상 콜백을 호출하기도 하고, 여러 개의 콜백을 클라이언트로부터 받아서 사용하기도 한다.


## 3.5.2 편리한 콜백의 재활용

템플릿/콜백 방식으로 반복적인 코드를 줄임으로써 클라이언트인 DAO의 메소드는 갈결해지고 최소한의 데이터 액세스 로직만 갖고있게 되었다.

그런데 익명 내부 클래스 코드가 답답해보인다.


### 콜백의 분리와 재활용

복잡한 익명 내부 클래스의 사용을 최소화할 수 있는 방법을 찾아보자.   

`deleteAll()` 메소드의 내용을 통틀어서 바뀔 수 있는 것은 오직 `delete from users`라는 문자열뿐이다.  
단순 SQL을 필요로 하는 콜백이라면 나머지 코드는 매번 동일할 것이다. 그렇다면 SQL 문장만 파라미터로 받아서 바꿀 수 있게 하고 메소드 내용 전체를 분리해 별도의 메소드로 만들어보자.   

### 콜백과 템플릿의 결합

재활용 가능한 콜백을 담은 메소드 `executeSql()` 메소드는 `UserDao`만 사용하기는 아깝다. 재사용 가능한 콜백을 담고 있는 메소드라면 DAO가 공유할 수 있는 템플릿 클래스 안으로 옮겨도 된다.   
엄밀히 말하면 템플릿은 `JdbcContext` 클래스가 아니라 `workWithStatementStrategy()` 메소드이므로 `JdbcContext` 클래스로 콜백 생성과 템플릿 호출이 담긴 `executeSql()` 메소드를 옮긴다고 해도 문제 될 것은 없다.  


일반적으로 성격이 다른 코드들은 가능한 분리하는 편이 낫지만, *하나의 목적을 위해 서로 긴밀하게 연관되어 동작하는 응집력이 강한 코드들은* 한 군데 모여 있는 게 유리하다.


## 3.5.3 템플릿/콜백의 응용

템플릿/콜백 패턴이 스프링이 제공해주는 독점적인 기술은 아니다. 하지만 스프링은 이 패턴을 적극적으로 활용한다.  

스프링에 내장된 것을 원리도 알지 못한 채로 기계적으로 사용하는 경우와 적용된 패턴을 이해하고 사용하는 경우는 큰 차이가 있으므로, 스프링의 기본이 되는 전략 패턴과 DI는 물론이고 템플릿/콜백 패턴도 익숙해지도록 학습할 필요가 있다.


고정된 작업 흐름을 갖고 있으면서 여기저기서 자주 반복되는 코드가 있다면 중복되는 코드를 분리할 방법을 생각해보는 습관을 기르자.


### 제네릭스를 이용한 콜백 인터페이스

만약 결과의 타입을 다양하게 가져가고 싶다면, 자바 언어에 타입 파라미터라는 개념을 도입한 제네릭스를 이용하면 된다. 제네릭스를 이용하면 다양한 오브젝트 타입을 지원하는 인터페이스나 메소드를 정의할 수 있다.























# 3.6





















# 3.7
