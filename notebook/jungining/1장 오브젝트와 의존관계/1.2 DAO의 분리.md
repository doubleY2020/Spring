---
title: "1장 오브젝트와 의존관계"
date: 2020-02-08 16:48:00 -0400
categories: Spring
comments: true
---


# 1.1 초난감 Dao

**DAO(Data Access Object)** : DB를 사용해 데이터를 조회하거나 조작하는 기능을 전담하도록 만든 오브젝트를 말한다.

jdbc API를 통해 DB에 저장하고 조회할 수 있는 간단한 DAO를 만들어보자.

## 1.1.1 User

사용자 정보 저장용 자바빈 User 클래스

```java

package user.domain;

public class User {
    String id;
    String name;
    String password;

    public String getId() {
        return id;
    }
    public void setId(String id) {
        this.id = id;
    }
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    public String getPassword() {
        return password;
    }
    public void setPassword(String password) {
        this.password = password;
    }
}


```


**JavaBean이란** : 비주얼 컴포넌트라기보다는 다음 두 가지 관례를 따라 만들어진 오브젝트를 가리킨다. 간단히 빈이라고 부르기도 한다.
- 디폴트 생성자 : 자바빈은 파라미터가 없는 디폴트 생성자를 가지고 있어야 한다. 툴이나 프레임워크에서 리플렉션을 이용해 오브젝트를 생성하기 때문에 필요하다.
- 프로퍼티 : 자바빈이 노출하는 이름을 자긴 속성. 프로퍼티는 setter와 getter을 이용해 수정 또는 조회 가능하다.



User오브젝트에 담긴 정보가 실제로 보관될 DB테이블을 하나 만들어보자.

```sql
create table springbook.users (
	id varchar(10) primary key,
    name varchar(20) not null, 
    password varchar(10) not null
	)
```


## 1.1.2 UserDao, 1.1.3 Main을 통한 테스트
사용자 정보를 DB에 넣고 관리할 수 있는 DAO클래스를 만들어보자. 

JDBC를 이요하는 작업의 일반적인 순서는 다음과 같다.

1. DB연결을 위한 Connection을 가져온다.
2. SQL을 담은 statement(또는 PreparedStatement)를 만든다.
3. 만들어진 Statement를 실행한다.
4. 조회의 경우 SQL의 실행 결과를 ResultSet으로 받아서 정보를 저장할 오브젝트(여기서는 User)에 담아준다.
5. 작업중에 생성된 Connection, Statement, ResultSet과 같은 리소스는 작업을 마친 후 반드시 닫아준다.
6. JDBC API가 만들어내는 Exception를 직접 처리하거나, 메소드에 throws를 선언해서 예외가 발생하면 메소드 밖으로 던지게 한다.


```java
package user.dao;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;

import user.domain.User;

public class UserDao {
    public void add(User user) throws ClassNotFoundException, SQLException {
        Class.forName("com.mysql.jdbc.Driver");
        Connection c = DriverManager.getConnection("jdbc:mysql://localhost/springbook?useSSL=false", "root",
                "root123!");

        PreparedStatement ps = c.prepareStatement(
                "insert into users(id, name, password) values(?,?,?)");
        ps.setString(1, user.getId());
        ps.setString(2, user.getName());
        ps.setString(3, user.getPassword());

        ps.executeUpdate();

        ps.close();
        c.close();
    }


    public User get(String id) throws ClassNotFoundException, SQLException {
        Class.forName("com.mysql.jdbc.Driver");
        Connection c = DriverManager.getConnection("jdbc:mysql://localhost/springbook?useSSL=false", "root",
                "root123!");
        PreparedStatement ps = c
                .prepareStatement("select * from users where id = ?");
        ps.setString(1, id);

        ResultSet rs = ps.executeQuery();
        rs.next();
        User user = new User();
        user.setId(rs.getString("id"));
        user.setName(rs.getString("name"));
        user.setPassword(rs.getString("password"));

        rs.close();
        ps.close();
        c.close();

        return user;
    }

    public static void main(String[] args) throws ClassNotFoundException, SQLException {
        UserDao dao = new UserDao();

        User user = new User();
        user.setId("whiteship");
        user.setName("백기선");
        user.setPassword("married");

        dao.add(user);

        System.out.println(user.getId() + " 등록 성공");

        User user2 = dao.get(user.getId());
        System.out.println(user2.getName());
        System.out.println(user2.getPassword());

        System.out.println(user2.getId() + " 조회 성공");
    }

}


```

[[IntelliJ] JDBC 연동, Java MySQL 연결](https://whitepaek.tistory.com/18) 글을 보고 intellij에 mysql connector을 연결해줬다.



실행결과 


```console

/Library/Java/JavaVirtualMachines/jdk-11.0.1.jdk/Contents/Home/bin/java "-javaagent:/Applications/IntelliJ IDEA.app/Contents/lib/idea_rt.jar=59733:/Applications/IntelliJ IDEA.app/Contents/bin" -Dfile.encoding=UTF-8 -classpath /Users/YJI/src/Spring/source/junginig/Springbook/out/production/Springbook:/Users/YJI/src/mysql-connector-java-5.1.48/mysql-connector-java-5.1.48-bin.jar user.dao.UserDao
whiteship 등록 성공
백기선
married
whiteship 조회 성공
```


이제부터 이 문제 많은 초난감 DAO 코드를 객체지향 기술의 원리에 충실한 스프링 코드로 바꿔보자. 

# 1.2 DAO의 분리

## 1.2.1 관심사의 분리

프로그램의 기초 중에 **관심사의 분리(Separation of Concerns)** 라는게 있다. 

이를 객체지향에 적용해보면,
- 관심이 같은 것끼리는 하나의 객체 안으로 또는 친한 객체로 모이게 하고,
- 관심이 다른 것은 가능한 한 따로 떨어져서 서로 영향을 주지 않도록 분리하는 것

이라고 생각할 수 있다.


## 1.2.2 커넥션 만들기의 추출

UserDao의 add()메소드 하나에서 세 가지 관심사항을 발견할 수 있다.

### UserDao의 관심사항
1. DB와 연결을 위한 커넥션을 어떻게 가져올까
2. 사용자 등록을 위해 db에 보낼 sql문장을 담을 Statement를 만들고 실행하는 것
3. 작업 후 Statement와 Connection 오브젝트를 닫아 공유 리소스를 시스템에 돌려주는 것

### 중복 코드의 메소드 추출

가장 먼저 할 일은 중복된 코드를 분리하는것이다. 중복된 DB연결 코드를 getConnection()이라는 이름의 독립적인 메소드로 만들어준다.


```java
    public User get(String id) throws ClassNotFoundException, SQLException {
        Class.forName("com.mysql.jdbc.Driver");
        Connection c = getConnection();
...
    public void add(User user) throws ClassNotFoundException, SQLException {
        Class.forName("com.mysql.jdbc.Driver");
        Connection c = getConnection();    
...
                                                                           
    // 중복된 코드를 독립적인 메소드로 만들어 중복을 제거했다.
    private Connection getConnection() throws ClassNotFoundException, SQLException{
        Class.forName("com.mysql.jdbc.Driver");
        Connection c = DriverManager.getConnection("jdbc:mysql://localhost/springbook?useSSL=false", "root",
                "root123!");
        return c;
    }
```



## 1.2.3 DB 커넥션 만들기의 독립

만약, 고객에 의해 DB커넥션을 가져오는 방법이 종종 변경될 가능성이 있다면, 

어떻게 해야 UserDao 소스코드를 고객사에 제공해주지 않고도 고객 스스로 DB커넥션 생성 방식을 적용해가면서 UserDao를 사용하게 할 수 있을까?


### 상속을 통한 확장

기존 UserDao 코드를 한단계 더 분리하면 된다.
UserDao에서 메소드의 구현 코드를 제공하고 getConnection()을 추상 메소드로 만들어놓는다. 

<img width="400" alt="상속을 통한 UserDao 확장 방법" src="https://img1.daumcdn.net/thumb/R720x0.q80/?scode=mtistory2&fname=http%3A%2F%2Fcfile7.uf.tistory.com%2Fimage%2F1702B44B4ECE64512C5931">

```java

public abstract class UserDao 
    ...
    
    //구현코드는 제거되고 추상 메소드로 바뀌었다. 메소드의 구현은 서브클래스가 담당한다.
    abstract protected Connection getConnection() throws ClassNotFoundException, SQLException ;

}

//상속을 통해 확장된 getConnection() 메소드
public class NUserDao extends UserDao {
	protected Connection getConnection() throws ClassNotFoundException,
			SQLException {
		// N사 DB connection 생성코드
		return c;
	}
}

public class DUserDao extends UserDao {
	protected Connection getConnection() throws ClassNotFoundException,
			SQLException {
		// D사 DB connection 생성코드
		return c;
	}
}

```
수정된 코드는

- UserDao : Dao의 핵심 기능인 어떻게 데이터를 등록하고 가져올 것인가 (SQL작성, 파라미터 바인딩, 쿼리 실행, 검색정보 전달)
- NuserDao, DUserDao : DB연결은 어떻게 할 것인가

두 관심이 클래스 레벨로 구분이 되고 있다. 

클래스 계층구조를 통해 두 개의 관심이 독립적으로 분리되면서 변경 작업은 한층 용이해졌다. 

***Template Method Pattern*** : 슈퍼클래스에 기본적인 로직의 흐름을 만들고, 그 기능의 일부를 추상 메소드나 오버라이딩이 가능한 protected 메소드 등으로 만든 뒤 서브클래스에서 이런 메소드를 필요에 맞게 구현해서 사용하도록 하는 방법. 템플릿 메소드 패턴은 스프링에서 애용되는 디자인 패턴이다. 

***Factory Method Pattern*** : 서브클래스에서 구체적인 오브젝트 생성 방법을 결정하게 하는 것

- UserDao의 getConnection()메소드는 Connection 타입 오브젝트를 생성한다는 기능을 정의해놓은 추상 메소드고, UserDao의 서브클래스의 getConnection()은 어떤 Connecton 클래스의 오브젝트를 어떻게 생성할지를 결정하는 방법이라고 볼 수 있다. 

<img width="400" alt="Userdao에 적용된 팩토리 메소드 패턴" src="https://i.imgur.com/RSH9tOC.png">


# 1.3 DAO의 확장


오브젝트는 제각기 독특한 변화의 특징이 있다. 변화의 성격이 다르다는건 변화의 이유의 시기, 주기 등이 다르다는 뜻이다.
추상클래스를 만들고 이를 상속한 서브클래스에서 변화가 필요한 부분을 바꿔서 쓸 수 있게 만든 이유는 바로 이렇게 변화의 성격이 다른 것을 분리해서, 서로 영향을 주지 않은 채로 각각 필요한 시점에 독립적으로 변경할 수 있게 하기 위해서다. 그러나 여러가지 단점이 많은 상속이라는 방법을 사용했기 때문에 이를 개선해보자.

## 1.3.1 클래스의 분리

두 개의 관심사를 본격적으로 독립시키면서 동시에 손쉽게 확장할 수 있는 방법을 알아보자. 

- DB커넥션과 관련된 부분을 서브클래스가 아니라, 아예 별도의 클래스에 담는다. 
- 이렇게 만든 클래스를 UserDao가 이용하게 하면 된다.


```java
//독립시킨 연결 기능인 SimpleConnectionMaker
public class SimpleConnectionMaker {
	public Connection getConnection() throws ClassNotFoundException,
			SQLException {
		Class.forName("com.mysql.jdbc.Driver");
		Connection c = DriverManager.getConnection("jdbc:mysql://localhost/springbook?useSSL=false", "root",
				"root123!");
		return c;
	}
}

// 독립된 SimpleconnectionMaker을 사용하게 만든 UserDao
public abstract class UserDao {
    private SimpleConnectionMaker simpleConnectionMaker;

    public UserDao() {
        // 상태를 관리하는 것도 아니니 한 번만 만들어 인스턴스 변수에 저장해두고 메소드에서 사용하게 한다.
        this.simpleConnectionMaker = new SimpleConnectionMaker();
    }

    public void add(User user) throws ClassNotFoundException, SQLException {
        Connection c = this.simpleConnectionMaker.getConnection();
                                                                                                                              
```

클래스를 분리시켰지만, 두 가지 문제가 존재한다.
1. UserDao의 코드가 SimpleConnectionMaker라는 특정 클래스에 종속되어 있기 때문에 상속을 사용했을 때처럼 UserDao의 수정 없이 DB커넥션 생성 기능을 변경할 방법이 없다. 
2. DB커넥션을 제공하는 클래스가 어떤것인지를 UserDao가 구체적으로 알고있어야 한다

## 1.3.2 인터페이스의 도입

가장 좋은 해결책은 두개의 클래스가 서로 긴밀하게 연결되어 있지 않도록 중간에 추상적인 느슨한 연결고리(Interface)를 만들어주는 것이다. 

인터페이스는 자신을 구현한 클래스에 대한 구체적인 정보는 모두 감춰버린다. 

결국, 오브젝트를 만들려면 구체적인 클래스 하나를 선택해야겠짖만 인터페이스로 추상화해둔 최소한의 경로를 통해 접근하는 쪽에서는 오브젝트를 만들때 사용할 클래스가 무엇인지 몰라도 된다.



<img width="338" alt="image" src="https://user-images.githubusercontent.com/11023497/76145684-22689f00-60cf-11ea-91a4-99570459f17d.png">


```java

public interface ConnectionMaker {
	public Connection makeConnection() throws ClassNotFoundException,
			SQLException;
}

public class DConnectionMaker implements ConnectionMaker {
    public Connection makeConnection() throws ClassNotFoundException, SQLException{
        //D사의 독자적 방법으로 Conneciton을 생성하는 코드
    }
}
public abstract class UserDao {
    // 인터페이스를 통해 오브젝트에 접근하므로 구체적인 클래스 정보를 알 필요가 없다.
    private ConnectionMaker connectionMaker;

    public UserDao() {
       connectionMaker = new DConnectionMaker();
    }

    public void add(User user) throws ClassNotFoundException, SQLException {
        Connection c = connectionMaker.makeConnection();

```


그런데, 여전히 DConnection 클래스의 생성자를 호출해서 오브젝트를 생성하는 코드가 남아있다.


## 1.3.3 관계설정 책임의 분리


UserDao에는 여전히 분리되지 않은 관심사항이 남아있다. UserDao와 UserDao가 사용할 ConnectionMaker의 특정 구현 클래스 사이의 관계를 설정해주는것에 대한 관심이다.

- 클라이언트 : 사용하는 오브젝트
- 서비스 : 사용되는 오브젝트

UserDao를 사용하는 클라이언트가 적어도 하나는 존재할 것이다. UserDao의 클라이언트 오브젝트가 제 3의 관심사항 UserDao와 ConnectionMaker구현 클래스의 관계를 결정해주는 기능을 분리해서 두기에 적절한 곳이기 때문이다. 


현재는 UserDao 클래스의 main()메소드가 UserDao클라이언트라고 볼 수 있다. 
1. UserDao에 있던 main()메소드를 UserDaoTest라는 이름의 클래스를 하나 만들고 옮겨보자. 
2. UserDao의 생성자를 수정해서 클라이언트가 미리 만둘어둔 ConnectionMaker의  오브젝트를 전달받을 수 있도록 파라미터를 하나 추가한다.


```java

    public UserDao( ConnectionMaker connectionMaker) {
     this.connectionMaker = connectionMaker;
    }

public class UserDao { 
    private ConnectionMaker connectionMaker;

    public UserDao( ConnectionMaker connectionMaker) {
     //DConnetionMaker 사라졌다! 
     this.connectionMaker = connectionMaker;
    }
                      
public class UserDaoTest {
	public static void main(String[] args) throws ClassNotFoundException, SQLException {
		
		// UserDao가 사용할 ConnecionMaker 구현 클래스를 결정하고, 오브젝트를 만든다
		ConnectionMaker connectionMaker = new DConnectionMaker();
		
		// 1. UserDao 생성
        // 2. 사용할 ConnectionMaker타입의 오브젝트 제공
        // 결국 두 오브젝트 사이의 의존관계 설정 효과
		UserDao dao = new UserDao(connectionMaker);
```


UserDaoTest는 UserDao와 ConnectionMaker 구현 클래스와의 런타임 오브젝트 의존관계를 설정하는 책임을 담당해야 한다. 그래서 특정 ConnectionMaker구현 클래스의 오브젝트를 만들고, UserDao 생성자 파라미터에 넣어 두 개의 오브젝트를 연결해준다. 그리고 UserDao에 대한 테스트 작업을 수행한다. 


인터페이스를 도입하고 클라이언트의 도움을 얻는 방법은 상속을 통한 방법보다 훨씬 유연하다. ConnectionMaker라는 인터페이스를 사용하기만 한다면 다른 DAO클래스에도 ConnectionMaker의 구현 클래스들을 그대로 적용할 수 있기 때문이다.

## 1.3.4 원칙과 패턴

### 1. 개방 폐쇄 원칙(OCP, Open-Closed Principle)

**: 클래스나 모듈은 확장에는 열려 있어야 하고, 변경에는 닫혀있어야 한다.**

ex)UserDao는 DB연결방법이라는 기능을 확장하는데는 열려있고, 자신의 핵심 기능을 구현한 코드는 그런 변화에 영향을 받지 않고 유지할 수 있으므로 변경에는 닫혀있다.

<img width="500" alt="image" src="https://t1.daumcdn.net/cfile/tistory/998377505A7859B530">

인터페이스를 통해 제공되는 확장 포인트는 확장을 위해 활짝 개방되어있다. 반면 인터페이스를 이용하는 클래스는 자신의 변화가 불필요하게 일어나지 않도록 굳게 폐쇄되어있다. 


### 2. 높은 응집도(Cohesion)와 낮은 결합도(Coupling)
**1. 높은 응집도** : 변경이 일어날 때 모듈의 많은 부분이 함께 바뀐다

**2. 낮은 결합도** : 하나의 변경이 발생할 때 여타 모듈과 객체로 변경에 대한 요구가 전파되지 않는 상태.

*여기서 결합도란, 하나의 오브젝트가 변경이 일어날 때 관계를 맺고 있는 다른 오브젝트에게 변화를 요구하는 정도.


### 3. 전략 패턴(Strategy Pattern)

: 자신의 기능 Context에서, 필요에 따라 변경이 필요한 알고리즘을 인터페이스를 통해 통째로 외부로 분리시키고, 이를 구현한 구체적인 알고리즘 클래스를 필요에 따라 바꿔서 사용할 수 있게 하는 디자인 패턴


# 1.4 제어의 역전(IoC : Inversion of Control)

## 1.4.1 오브젝트 팩토리

초난감 DAO를 리팩토링 했지만, 클라이언트인 UserDaoTest가 UserDao가 직접 담당하던 기능인 '어떤 ConnectionMaker 구현 클래스를 사용할지를 결정하는 기능'을 떠맡았다.
이 또한 분리해버리자.

- UserDao와 ConnecitonMaker 구현 클래스의 오브젝트를 만드는 것
- 만들어진 두 개의 오브젝트가 연결돼서 사용될 수 있도록 관계를 맺어주는 것

으로 분리할 수 있다.

### Factory

> Factory : 객체의 생성 방법을 결정하고 그렇게 만들어진 오브젝트를 돌려주는 것 

디자인 패턴에서 말하는 특별한 문제를 해결하기 위해 사용되는 추상 팩토리 패턴이나 팩토리 메소드 패턴과는 다르다. 단지 오브젝트를 생성하는 쪽과, 생성된 오브젝트를 사용하는 쪽의 역할과 책임을 분리하려는 목적으로 사용한다.

0. DaoFactory라는 팩토리 역할을 맡을 클래스를 만들고, 
1. UserDao, ConnectionMaker 관련 생성 작업을 DaoFactory로 옮긴다.
2. UserDaoTest에서는 DaoFactory에 요청해서 미리 만들어진 UserDao오브젝트를 가져와 사용하게 만든다.


```java
public class DaoFactory {
	public UserDao userDao() {
	    // 팩토리의 메소드는 UserDao타입의 오브젝트를 어떻게 만들고, 어떻게 준비시킬지를 결정한다.
        ConnectionMaker connectionMaker = new DConnectionMaker();
        UserDao userDao = new UserDao(connectionMaker);
        return userDao;
    }
}


public class UserDaoTest {
	public static void main(String[] args) throws ClassNotFoundException, SQLException {

		// UserDao가 사용할 ConnecionMaker 구현 클래스를 결정하고, 오브젝트를 만든다
		ConnectionMaker connectionMaker = new DConnectionMaker();

		UserDao dao = new DaoFactory().userDao();
```

### 설계도로서의 팩토리
분리된 오브젝트의 역할과 관계를 분석해보자.
 - 실질적인 로직을 담당하는 컴포넌트 : UserDao와 ConnectionMaker는 App의 핵심적인 데이터 로직과 기술 로직을 담당
 - 애플리케이션을 구성하는 컴포넌트의 구조와 관계를 정의한 설계도와 같은 역할 : DaoFactory 는 이런 애플리케이션의 오브젝트들을 구성하고 관계를 정의하는 책임

Factory를 분리했을 때, 애플리케이션의 컴포넌트 역할을 하는 오브젝트와, 애플리케이션의 구조를 결정하는 오브젝트를 분리했다는 데 가장 의미가 있다.

## 1.4.2 오브젝트 팩토리의 활용

만약 DaoFactory에 UserDAo가 아닌 다른 DAO(ex. AccountDao, MessageDao)의 생성 기능을 넣으면 어떻게 될까? 

이 경우, UserDao를 생성하는 userDao()메소드를 복사해서 만든다면 문제가 발생한다. ConnectionMaker 구현 클래스의 오브젝트를 생성하는 코드가 반복되는 것이다.

ConnectionMaker의 구현 클래스를 결정하고 오브젝트를 만드는 코드를 별도의 메소드로 뽑아내자. 

```java
public class DaoFactory {
	public UserDao userDao() {
	  return new UserDao(connectionMaker());
    }

    public ConnectionMaker connectionMaker(){
	    return new DConnectionMaker();
    }
}

```

## 1.4.3 제어권의 이전을 통한 제어관계 역전

> 제어의 역전(IoC : Inversion of Control) : 프로그램의 제어 흐름 구조가 뒤바뀌는 것

제어의 역전이란 기존에 오브젝트가 자신이 사용할 오브젝트를 스스로 선택하고, 생성했던 제어 흐름의 구조를 뒤바꾸는 것이다. 


예를 들어, 프레임워크의 경우도 제어의 역전 기능이 적용된 대표적인 기술이다. 프레임워크는 라이브러리와 다르다. 라이브러리를 사용하는 애플리케이션 코드는 애플리케이션 흐름을 직접 제어한다. 반면에 프레임워크는 거꾸로 애플리케이션 코드가 프레임워크에 의해 사용된다. 

IoC를 적용함으로써
- 설계가 깔끔해지고
- 유연성이 증가하며
- 확장성이 증가한다.

스프링은 IoC를 모든 기능의 기초가 되는 기반기술로 삼고있으며, IoC를 극한까지 사용하고 있는 프레임워크다. 이제 스프링이 제공하는 IoC에 대해 살펴보자.


# 1.5 스프링의 IoC
스프링의 핵심을 담당하는 것은 Bean Factory 또는 Application Context라고 불리는 것이다. 이 두가지는 DaoFactory가 하는 일을 좀더 일반화한 것으로 설명할 수 있다.

## 1.5.1 오브젝트 팩토리를 이용한 스프링 IoC

### Application Context와 설정정보

> Bean이란? 스프링이 제어권을 가지고 직접 만들고 관계를 부여하는 오브젝트.

 - 오브젝트 단위의 Application Component를 말한다.
 - 스프링 컨테이너가 생성, 관계설정, 사용 등을 제어해주는 제어의 역전(IoC : Inversion of Control)이 적용된 오브젝트

> Bean Factory란? 빈의 생성/관계설정 등의 제어를 담당하는 IoC 오브젝트
  - 보통 빈 팩토리 보다는 이를 좀더 확장한 Application Context를 사용한다.

> Application Context : 빈(오브젝트)의 생성, 관계설정 등의 제어 작업을 총괄한다.
- IoC 방식을 따라 만들어진 일종의 Bean Factory. 
- 설정 정보를 직접 담고 있진 않고, 설정정보를 담고 있는 무언가를 가져와 이를 활용하는 범용적인 IoC 엔진이다.
- 애플리케이션 로직을 담당하지는 않지만 IoC 방식을 이용해 컴포넌트를 생성하고, 사용할 관계를 맺어주는 등의 책임을 담당 (마치 건물의 설계도)

### DaoFactory를 사용하는  Application Context
DaoFactory를 스프링의 Bean Factory가 사용 할 수 있는 설정정보로 만들어보자.
두 가지 Annotation을 붙여준다.
1. @Configuration : 스프링이 Bean Factory를 위한 오브젝트 설정을 담당하는 클래스라고 인식할 수 있도록 클래스 위에 단다.
2. @Object : 오브젝트를 만들어주는 메소드에 단다.

```java
package user.dao;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration // 애플리케이션 컨텍스트 또는 빈 팩토리가 사용할 설정정보라는 표시
public class DaoFactory {
    @Bean // 오브젝트 생성을 담당하는 IoC용 메소드 라는 표시
    public UserDao userDao() {
        return new UserDao(connectionMaker());
    }

    @Bean
    public ConnectionMaker connectionMaker(){
        return new DConnectionMaker();
    }
}

```
이제 DaoFactory를 설정정보로 사용하는 Application Context를 만들어 보자.

Application Context는 ApplicationContext타입의 오브젝트다. @Configuration이 붙은 자바 코드를 설정정보로 사용하려면 AnnotationConfigApplicationContext를 사용하면 된다.

```java
// Application Context가 적용된 UserDaoTest
public class UserDaoTest {
	public static void main(String[] args) throws ClassNotFoundException, SQLException {

        ApplicationContext context = new AnnotationConfigApplicationContext(DaoFactory.class);
		UserDao dao = context.getBean("userDao", UserDao.class);
```
 - `getBean()`메소드는 ApplicationContext가 관리하는 오브젝트를 요청하는 메소드다. DaoFactory에서 @Bean 어노테이션을 userDao라는 메소드에 붙였었는데, 이 메소드가 빈의 이름이 된다. 

> UserDao를 가져오는 메소드는 하나뿐인데 왜 굳이 이름을 사용하나?
 -> 생성하는 방식이나 구성을 다르게 가져오는 메소드를 추가할 수 있기 때문.
 
  - `getBean()`메소드는 기본적으로 Obejct타입으로 리턴하게 되어있어, 다시 캐스팅을 해줘야한다. Generic메소드 사용을 이용해 리턴 타입을 주면, 지저분한 캐스팅 코드를 사용하지 않아도 된다.

## 1.5.2 Application Context의 동작방식


## 1.5.3 스프링 IoC의 용어 정리
- Bean
- Bean Factory
- Application Context
- 설정정보/설정 메타정보(Configuration metadata)
- Container 또는 IoC Container
- Spring Framework