# 1.6 싱글톤 레지스트리와 오브젝트 스코프
스프링의 Appplication Context와 직접 만든 오브젝트 팩토리와는 중요한 차이점이 있다. 어떤 차이점인지 확인해보자.

먼저, DaoFactory의 userDao()를 여러 번 호출했을때 동일한 오브젝트가 돌아올까?

### 오브젝트의 동일성과 동등성
동일성은 `==` 연산자로, 동등성은 `equals`메소드를 이용해 비교한다.
- 동일하다면 사실은 하나나의 오브젝트만 존재하는 것이고, 두개의 오브젝트 레퍼런스 변수를 갖고 있을 뿐
- 동등한 경우에는 두 개의 각기 다른 오브젝트가 메모상에 존재하는 것인데, 동등성 기준에 따라 두 오브젝트 정보가 동등하다고 판단하는 것

확인을 위해 콘솔에 출력해보자.
```java
DaoFactory factory = new DaoFactory(); //매번 new 연산자에 의해 새로운 오브젝트가 만들어지게 되어있다.
UserDao dao1 = factory.userDao();
UserDao dao2 = factory.userDao();

System.out.println(dao1); //user.dao.UserDao@38082d64
System.out.println(dao2); //user.dao.UserDao@dfd3711
```

콘솔 출력결과, 오브젝트 두 개가 생겼다. 
userDao를 계속 호출하면 계속해서 새로운 오브젝트가 만들어질 것이다.


```java
ApplicationContext context = new AnnotationConfigApplicationContext(DaoFactory.class);
UserDao dao3 = context.getBean("userDao", UserDao.class);
UserDao dao4 = context.getBean("userDao", UserDao.class);

System.out.println(dao3); //user.dao.UserDao@48f278eb
System.out.println(dao4); //user.dao.UserDao@48f278eb
```
반면, ApplicationContext를 이용하면 매번 동일한 오브젝트를 돌려준다. 왜 그럴까?


## 1.6.1 싱글톤 레지스트리로서의 애플리케이션 컨텍스트
Application Context는 싱글톤을 저장하고 관리하는 싱글톤 레지스트리이다. 디자인 패턴에서 나오는 싱글톤 패턴과 유사하지만 그 구현 방법은 확연히 다르다.

### 서버 애플리케이션과 싱글톤
> 싱글톤 패턴 : 애플리케이션 안에 제한된 수, 대개 한 개의 오브젝트만 만들어 사용하는것

스프링이 주로 적용되는 대상은 자바 엔터프라이즈 기술을 사용하는 서버환경이다. 스프링이 처음 설계됐던 대규모 서버 환경은 서버 하나당 최대로 초당 수백번씩 요청을 받아 처리할 수 있는 높은 성능이 요구되는 환경이었다. 이 경우, 요청이 올때마다 오브젝트를 만들면 안되겠지 당연히..

그래서 엔터프라이즈 분야에서는 **서비스 오브젝트** 라는 개념을 일찍부터 사용해왔다. 서블릿이 자바 엔터프라이즈 기술의 가장 기본적인 서비스 오브젝트라고 할 수 있다. 서블릿은 대부분 싱글톤으로 동작한다.


### 싱글톤 패턴의 한계
자바의 싱글톤 구현 방법은 보통 이렇다.
1. 클래스 밖의 생성을 막기위해 생성자를 private으로 만든다.
2. 자신과 같은 타입의 static 필드를 정의하여 생성된 싱글톤 오브젝트를 정의한다.
3. static factory method인 getInstance()를 만들고 이 메소드가 최초로 호출되는 시점에 한 번만 오브젝트가 만들어지게 한다.
4. 한 번 오브젝트가 생성된 후에는 getInstance()를 통해 이미 만들어둔 오브젝트를 넘긴다.

싱글톤 패턴을 적용한 UserDao의 private으로 바뀐 생성자는 외부에서 호출할 수 없기때문에 DaoFactory에서 UserDao를 생성하며 ConnectionMaker 오브젝트를 넣어주는게 불가능해졌다. 

일반적으로 싱글톤 구현 방식에는 이런 문제가 있다.
- private 생성자를 갖고 있기 때문에 상속할 수 없다.
- 싱글톤은 테스트가 힘들거나 아예 불가능하다.
- 서버환경에서는 싱글톤이 하나만 만들어진다는것이 보장되지 않는다 : 클래스 로더를 어떻게 구성하느냐에 따라 하나 이상의 오브젝트가 만들어질 수 있다. 여러개의 JVM에 분산돼 설치되는 경우도 마찬가지
- 싱글톤의 사용은 global(전역) state를 만들 수 있기 때문에 바람직하지 못하다 : 싱글톤은 사용하는 클라이언트가 정해져 있지 않아 어플리케이션 어디서든지 쉽게 접근/사용이 가능해진다.

### 싱글톤 레지스트리
싱글톤 패턴의 구현 방식은 위와 같은 단점이 있기 때문에, 스프링은 *직접* 싱글톤 형태의 오브젝트를 만들고 관리하는 기능을 제공한다.
그게 바로 싱글톤 레지스트리!

**싱글톤 레지스트리의 장점**
1. 평범한 자바 클래스를 싱글톤으로 활용하게 해준다.
2. public 생성자를 가질 수 있다.
3. 스프링이 지지하는 객체지향적 설계 방식과 원칙, 디자인패턴을 적용하는데 아무런 제약이 없다.


## 1.6.2 싱글톤과 오브젝트의 상태
싱글톤으로 만들어지기 때문에 주의할 점
> 상태정보를 내부에 갖지 않은 Stateless 방식으로 만들어져야 한다.

다중 사용자의 요청을 한번에 처리하는 스레드들이 동시에 싱글톤 오브젝트의 인스턴스 변수를 수정하는것은 매우 위험하다. DB나 서버, 리소스로부터 생성한 정보는 파라미터와 로컬변수, 리턴값 등을 이용해라.
기존의 UserDao에서도 인스턴스 변수로 정의해서 사용한 것이 있다. ConnectionMaker 인터페이스 타입의 connectionMaker는 읽기전용의 정보이기 때문이다. 읽기전용의 속성을 가진 정보라면 싱글톤에서 인스턴스 변수로 사용해도 좋다. 


## 1.6.3 스프링 빈의 스코프
> Scope : 빈이 생성되고, 존재하고, 적용되는 범위

스프링 빈의 기본 스코프는 싱글톤 스코프를 갖는다. 컨테이너 내에 한 오브젝트만 만들어져서, 강제로 제거하지 않는 한 스프링 컨테이너가 존재하는 동안 유지된다.

경우에 따라 싱글톤 외의 스코프(prototype scope, request scope, session scope)도 있다.

