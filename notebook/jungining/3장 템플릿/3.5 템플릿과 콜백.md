# 3.5 템플릿과 콜백

- 템플릿/콜백 패턴 : 복잡하지만 바뀌지 않는 일정한 패턴을 갖는 작업 흐름이 존재하고, 그 중 일부부분 자주 바꿔서 사용해야 하는 경우에 적합한 구조

## 3.5.1 템플릿/콜백의 동작원리
- 템플릿 : 전략 패턴의 컨텍스트, 고정된 작업 흐름을 가진 코드를 재사용한다.
- 콜백 : 익명 내부 클래스로 만들어지는 오브젝트, 템플릿 안에서 호출되는 것을 목적으로 만들어진 오브젝트

### 템플릿/콜백의 특징

1. 보통 _단일 메소드 인터페이스_ 를 사용한다 : 템플릿의 작업 흐룸 중 특정 기능을 위해 한 번 호출되는 경우가 일반적이기 때문
2. 콜백 인터페이스의 메소드에는 보통 _파라미터_ (템플릿의 작업 흐름 중에 만들어지는 컨텍스트 정보 전달받을 때 사용)가 있다.
3. 매번 메소드 단위로 사용할 오브젝트를 새롭게 전달받는다.
4. 콜백 오브젝트가 내부 클래스로서 자신을 생성한 클라이언트 메소드 내의 정보를 직접 참조한다.
5. 클라이언트와 콜백이 강하게 결합된다.

## 3.5.2 편리한 콜백의 재활용
템플릿/콜백 방식은 많은 장점이 있다. JdbcContext를 사용하기만 해도 기존에 발생했던 여러 가지 문제점과 불편한 점을 제거할 수 있다. 

그런데, 아쉬운 점이 있다. 익명 클래스를 이용하기 때문에 코드 가시성이 떨어진다.

### 콜백의 분리와 재활용
그러므로 복잡한 익명 내부 클래스의 사용을 최소화해보자. 언제나 그랬듯이 중복될 가능성이 있는 자주 바뀌지 않는 부분을 분리해보자. ```"delete form users"``` 라는 문자열만 바뀔 가능성이 있으므로, 파라미터만 받아서 sql문을 실행할 수 있도록 바꿔보자.


```java
public void deleteAll() throws SQLException {
    executeSql("delete from users");
}
private void executeSql(final String query) throws SQLException{
   ...
}
```
이렇게 해서 재활용 가능한 콜백을 담은 메소드가 만들어졌다. 복잡한 익명 내부 클래스인 콜백을 직접 만들 필요가 없어졌다.

### 콜백과 템플릿의 결합
executeSql()은 UserDao만 쓰기는 아깝다. 재사용 가능한 콜백을 담고 있는 메소드라면 DAO가 공유할 수 있는 템플릿 클래스 안으로 옮겨도 된다. JdbcContext로 executeSql을 옮기자. 그러면 이제 모든 DAO메소드에서 executeSql()을 사용할 수 있게 됐다. 결국 JdbcContext안에 클라이언트와 템플릿, 콜백이 모두 함께 공존하면서 동작하게 되는 구조가 됐다.

일반적으로는 성격이 다른 코드들은 가능한 한 분리하는 편이 낫지만, 이 경우는 반대다. 하나의 목적을 위해 서로 연간되어 동작하는 **응집력이 강한 코드들** 이기 때문에 한 군데 모여 있는것이 유리하다.


## 3.5.3 템플릿 / 콜백의 응용

템플릿/콜백 패턴이나 DI는 사실 스프링에서 사용할 수 있다거나 스프링이 제공해주는 독점적인 기술은 아니다. 하지만 스프링만큼 이 패턴을 적극적으로 활용하는 프레임워크는 없다. 스프링 개발자라면 당연히 스프링이 제공하는 템플릿/콜백 기능을 잘 사용할 수 있어야 한다. 고정된 작업 흐름을 가지고 있으면서 여기저기서 중복되는 코드가 있다면, 중복되는 코드를 분리할 방법을 생각해보는 습관을 기르자. (네)
